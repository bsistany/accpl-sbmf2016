
%% bare_conf.tex
%% V1.4b
%% 2015/08/26
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8b or later) with an IEEE
%% conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



\documentclass[conference]{IEEEtran}

\pagestyle{plain}

\usepackage{graphicx}
\usepackage{url}

\usepackage{listings,lstautogobble}
\usepackage{syntax}

\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily,
  frame=single,
  breaklines=true,
  morestring=[s]{"}{"},
  morecomment=[s]{?}{?},
  morecomment=[s]{!--}{--},
  commentstyle=\color{black},
  moredelim=[s][\color{black}]{>}{<},
  moredelim=[s][\color{black}]{\ }{=},
  stringstyle=\color{black},
  identifierstyle=\color{black},
  autogobble=true
}
\lstdefinelanguage{pseudo}
{
  morekeywords={
    IF, THEN, ELSE, END_IF, HOLDS, Permitted, NotPermitted, Unregulated, IN
  }
}
\lstdefinelanguage{Pucella2006}
{
  morekeywords={
    agreement, prin, asset, with, prePay, and, display, print, count
  }
}
\lstdefinelanguage{selinux}
{
  morekeywords={
    type, types, attrib, role, allow, user, constrain, avkind, 
	sourcetype, targettype, object-class, perm, allow, auditallow, dontaudit, neverallow,
	constrain, classes, perms, sourcetype, sourcerole, sourceuser, targettype, targetrole, targetuser
  }
}

\lstdefinelanguage{AST}
{
  basicstyle=\ttfamily,
  breaklines=true,
  morekeywords=[1]{
    prin, asset, subject, act, 
    policySet, primPolicySet, primExclusivePolicySet, primExclusivePolicySet, primInclusivePolicySet, primPolicy, 
    policy, policyId, primPrerequisite, prerequisite, constraint, agreement
  },
  tabsize=1,
}

\usepackage{acro}
\input{list-of-acronyms}

\newcommand{\syn}{\texttt}

\begin{document}

\title{A Certified Core Policy Language}

\author{\IEEEauthorblockN{Bahman Sistany\IEEEauthorrefmark{1}\IEEEauthorrefmark{2}
and Amy Felty\IEEEauthorrefmark{1}}
\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical Engineering and Computer Science\\
University of Ottawa, Ottawa, Canada}
\IEEEauthorblockA{\IEEEauthorrefmark{2}Irdeto Canada Corporation, Ottawa, Canada\\
Email: bahman.sistany@irdeto.com, afelty@uottawa.ca}}

\maketitle

\begin{abstract}
  We present the design and implementation of a Certified Core Policy
  Language (ACCPL) that can be used to express access-control
  policies.  We define formal semantics for ACCPL and use the Coq
  Proof Assistant to state theorems about this semantics, to develop
  proofs for those theorems and to machine-check the proofs ensuring
  correctness guarantees are provided. The main design goal for ACCPL
  is the ability to reason about the policies written in ACCPL with
  respect to specific questions such as safety. In addition, ACCPL and
  the established proofs are integrated such that extensions to
  expressive power may be explored by also extending identifiable and
  corresponding proof statements in the direction of the added
  expressivity.  To this end, ACCPL is small (the syntax and the
  semantics of ACCPL only take a few pages to describe), although we
  believe ACCPL supports the core features of many access-control
  policy languages.
\end{abstract}

% no keywords

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:intro}
We describe the design of a \ac{ACCPL} 
% new phrase
for expressing access control policies
%
and its implementation in the Coq Proof Assistant~\cite{BC04}.\footnote{Our complete proof development in Coq is available at
\url{http://www.site.uottawa.ca/~afelty/accpl/}.}

Using Coq to implement \ac{ACCPL} was an
important factor in its design, allowing us to address the trade-off
between expressive power and ease of formal proof of correctness.
The semantics of \ac{ACCPL} are specified by translation from policy
statements together with an access request and an environment
containing all the relevant facts, to decisions. We present results
showing the translation functions behave correctly with respect to the
decision question that asks whether a request to access a resource may
be granted or denied, given a policy. The translation functions also
cover the case where a given policy does not apply to a request in
which case a decision of non-applicable is rendered. Our results show
that for each access request, the translation algorithm terminates on
all input policies with a decision of granted, denied or
non-applicable.
To motivate the design of \ac{ACCPL}, let us review the definition of
``access-control'': Authorization refers to the process of rendering a
decision about whether to permit or deny access to a resource or asset
of interest, hence the term ``access-control.''

\subsection{Access Control Models}\label{subsec:models}

\ac{acl} is perhaps the oldest and the most basic access-control model. A list of subjects along with their rights are kept per resource or object of interest. Every time a subject makes an access request on an object, the \ac{acl} of the object is consulted and access is either granted or denied to the requester based on whether or not the requester is listed in the \ac{acl} and has the correct set of rights.

Capabilities based access-control works based on a list of objects and associated rights. The list of objects and the associated rights comprise an ``unforgeable'' ticket that a reference monitor checks to allow access (or not). Capabilities based systems don't need to authenticate users as \ac{acl} based systems do.

In \ac{rbac} systems a requester's role determines whether access is granted or denied. In this model, users belong to roles and rights are associated with roles so no direct association between users and rights exist. Roles are meant to group users and add flexibility when assigning rights. \ac{rbac} systems naturally solve the problem of assigning \ac{acl}s for a large group of users and manage the administration cost of changing users' rights in \ac{acl} based systems.


Despite many advantages of \ac{rbac} systems, some disadvantages also exist. Often a role needs to be decomposed into sub-roles based on the type of resource to be administered, and perhaps also based on the location that the resource serves. Basically \ac{rbac} suffers from a lack of a sub-typing mechanism whereby individual members of a group/role may be differentiated and access is granted or denied based on a more granular set of attributes. The \ac{abac} model was proposed to fulfill this granularity requirement. In \ac{abac} access control decisions are made based on a set of attributes, associated with the subject making the request, the environment, and/or the resource itself. 




%Although various access-control models exist, to 
%harmonize access control in large environments with many subjects and objects and disparate attributes, the \ac{pbac}~\cite{nist} model has been proposed. \ac{pbac} allows for a uniform and central access-control model among the various organizational units. There is also a need for large organizations to put in place mechanisms so that access-control rules can be easily audited. This calls for a data-driven approach to access-control where the data, in this case the access-control rules, are available to read and analyze. 
In order to harmonize access control in large environments with many subjects and objects and disparate attributes, \ac{pbac}~\cite{nist} model has been proposed. \ac{pbac} allows for a more uniform access-control model across the system. \ac{pbac} systems help create and enforce policies
that define who should have access to what resources, and under what circumstances.
There is also a need for large organizations to put in place mechanisms such that access-control rules can be easily audited. This calls for a data-driven approach to access-control where the data, in this case the access-control rules, are available to read and analyze. A data-driven approach like \ac{pbac} additionally helps with modularity of the system as changes in access control rules will have almost no impact to the underlying system the rules are meant to protect.

Because of the cited advantages, along with its generality and
widespread use, \ac{pbac} is the model \ac{ACCPL} implements.


\subsection{A Core Policy Language for PBAC Systems} 

Currently, the most popular \ac{rel}s include the
\ac{xrml}~\cite{Wang}, and \ac{odrl}~\cite{odrloneone}. Both of these
languages are XML-based and are considered declarative
languages. \ac{rel}s, or more precisely \ac{drel}s deal with the ``rights
definition'' aspect of the \ac{drm} ecosystem of digital assets. 
A \ac{drel}, allows the expression and definition
of digital asset usage rights so that other areas of the \ac{drm}
ecosystem, namely the enforcement mechanism and the usage tracking
components can function correctly.

\ac{drm} refers to the digital management of rights associated with
the access or usage of digital assets. There are various aspects of
rights management however.
According to Collier et al. in their white paper~\cite{collier},
%
digital rights management systems comprise these categories: defining
rights, distributing/acquiring rights, enforcing rights and finally
tracking usage.


The \ac{xacml}~\cite{xacml3} is another access control policy
specification language that is general, high-level, and allows
policies to be defined in a wide variety of domains.  It is an OASIS
standard that is becoming more widely used.  Like \ac{odrl} and
\ac{xrml}, it is based on XML and the \ac{pbac} model.  \ac{odrl} and
\ac{xrml} differ from \ac{xacml} by their focus on digital assets
protection and in general \ac{drm}, hence the term \ac{drel}.  Despite
this difference, \ac{drel}s and specifically \ac{odrl} are used to
arbitrate access to assets under conditions which is very similar to
how access control conditions are expressed in access control policy
languages such as \ac{xacml} and even \ac{selinux}~\cite{selinux}. In
fact several authors have worked on interoperability between \ac{rel}s
and access control policy languages, specifically between \ac{odrl}
and
\ac{xacml}~\cite{prados2005interoperability,maronas2009architecture}.


For a variety of reasons, we found \ac{xacml}, \ac{odrl} and \ac{xrml}
all to be ill-suited as the basis for a core policy language.  First,
they are all large languages that provide numerous features but suffer
from a lack of formal semantics. For example, the \ac{xacml} standard
is written in prose and contains quite a number of loose points that
may give rise to different interpretations and lead to different
implementation choices~\cite{DBLP:conf/essos/MasiPT12}.  Second, all
of these languages cover much more than policy expressions leading to
access decisions; they also address enforcement of policies (\ac{odrl}
and \ac{xrml} specifically and \ac{drm} in general distinguish
themselves from general access-control languages by additionally
addressing enforcement of policies beyond where the policies were
generated). Third, they are limited in terms of what can be built on
top of them; for example expressing hierarchical role-based
access-control in \ac{xacml} requires a fairly complex
encoding~\cite{Tschantz}.


A policy language based on logic and formal semantics but one that was small and extensible was needed. We use Pucella and Weissman's subset of \ac{odrl}~\cite{pucella2006} as the starting point for \ac{ACCPL} and in doing so treat digital rights as our main access-control application without loss of generality with respect to other applications, with the final goal of performing formal verification on policies written in \ac{ACCPL}.


%----------------------------------------------------------------------
\subsection{Formal Semantics for PBAC Languages}
%----------------------------------------------------------------------


Formal methods help ensure that a system behaves correctly with respect to a specification of its desired behavior~\cite{TAPL}. This specification of the desired behavior is what's referred to as \emph{semantics} of the system. Using formal methods requires defining precise and formal semantics, without which analysis and reasoning about properties of the system in question would become impossible. To formalize the semantics of \ac{pbac} languages several approaches have been attempted by various authors. Most are logic based~\cite{Halpern2008,pucella2006} while others are based on finite-automata~\cite{Holzer}, operational semantics based interpreters~\cite{Safavi-naini} and web ontology (from the Knowledge Representation Field)~\cite{Kasten2010MTS}. 
%
As described below, our work can be viewed as an extension
of~\cite{pucella2006}.


\subsection{Specific Problem}

Policy languages and the policies, sometimes called \emph{agreements}, written in those languages are meant to implement specific goals such as limiting access to specific assets. The tension in designing a policy language is usually between how to make the language expressive enough, such that the high-level and often service-oriented goals for policies may be expressed in the policy language, and how to make the policies verifiable with respect to the stated goals.

As stated earlier, an important part of fulfilling the verifiability goal is to have formal semantics defined for policy languages. For \ac{odrl}, authors of~\cite{pucella2006} define a formal semantics based on which they declare and prove a number of important theorems (their main focus is on stating and proving algorithm complexity results). However as with many paper-proofs, the language used to do the proofs while mathematical in nature, uses many intuitive justifications. As such these proofs are difficult to verify or to ``derive''. Furthermore the proofs can not be used directly to render a decision on a sample policy (e.g. whether to allow or deny access to an asset). Of course one may (carefully) construct a program based on these proofs for practical purposes but certifying such programs correct presents additional verification challenges, even assuming the original proofs were in fact correct.

\subsection{Contributions}\label{sec:contribs}

We have designed a policy based access-control language called \ac{ACCPL} based on \ac{odrl} and starting with definitions in~\cite{pucella2006}. The \ac{ACCPL} framework has been encoded in Coq which is both a programming language and a proof-assistant. We have specified and proved \ac{ACCPL} correct with respect to properties of interest in Coq which will allow us to extract programs from the proofs; the executable programs can be used on specific policies and a query, to render a specific decision such as ``a permission has been granted''. 

In addition, \ac{ACCPL} and the established proofs are integrated such that 
extensions to expressive power to \ac{ACCPL} may be explored by also extending identifiable and corresponding proof statements in the direction of the added expressivity. This integration has been implemented in what we call the Translation Function Framework (TFF) used for handling semantics as part our Coq encodings for \ac{ACCPL}.


To qualify \ac{ACCPL} ``easy to reason about'' we used Tschantz and Krishnamurthi's~\cite{Tschantz} reasonability properties as metrics of reasonability and designed the language such that \ac{ACCPL} would satisfy these properties.

We originally started with a specific subset of~\cite{pucella2006} so that we could concentrate on what we believed to be the essence or core of the language. Initially we intended to maintain the central semantic definitions including ``Closed World Assumptions''~\cite{pucella2006} where the semantics only specify explicitly \syn{Permitted} and \syn{NotPermitted} answers; we discovered, however, that the semantics as stated by Pucella and Weissman~\cite{pucella2006} are not explicit and therefore the decision question that asks whether a request to access a resource may be granted or denied, may not be answered in all cases. We have therefore made major modifications to the semantics of Pucella and Weissman's language such that an answer to a request for access to a resource may be determined unambiguously and for all cases.
 
%
Specifically, to consider all cases, our program evaluates a request
against each sub-policy of an agreement and returns one result for
each. The overall result is a list of decisions. We define what it
means to extract a single decision from a list of decisions and show
that it is always possible to extract a \emph{coherent} decision. The
definitions and theorems required to express this notion of
correctness are detailed in Section~\ref{sec:maintheorems}.


Given that \ac{ACCPL} is a core policy language with semantics that have been certified correct, we could use \ac{ACCPL} to implement various (more expressive) policy languages. In addition \ac{ACCPL} could be used as an intermediate language to reason about interoperability between those policy languages~\cite{prados2005interoperability,maronas2009architecture}. In this manner our language \ac{ACCPL} can be viewed as an extensible language, complete with defined and verified semantics, that can be used as the basis for implementing various policy languages with more expressive power. 

%For access to the Coq source code for \ac{ACCPL}, please refer to \url{http://www.site.uottawa.ca/~afelty/accpl/}.



 
\section{ACCPL Syntax}
%% Coq Syntax chapter

We follow the style of~\cite{pucella2006} by using abstract syntax to express policy statements in \ac{ACCPL}. Abstract syntax is a more compact representation than XML which is what all the XML-based policy languages such as \ac{odrl} use. Furthermore abstract syntax simplifies specifying the semantics as we shall see later.


\subsection{Environmental Facts}\label{sec:odrl0}
To determine the outcome of requests evaluated against policies,
specified conditions in those policies must be evaluated with respect
to environmental facts. In the \ac{drm} realm with its focus on usage
control, the kinds of facts that are typically tracked in the
environment include a count of how many times an asset has been
accessed, or perhaps the amount a subject has paid to access an asset. In \ac{ACCPL}, agreements and facts (i.e. environments) will
refer to a count of how many times each policy should be used and has
been used respectively, to justify an action.
Although our core language includes only one kind of fact, we choose
it just for illustration purposes, and extending it to other kinds is
straightforward.

\subsection{Abstract Syntax for ACCPL} \label{sec:productionast}

\newcommand*{\Comment}[1]{\hfill\makebox[7.0cm][l]{#1}}%
\newcommand*{\CommentPP}[1]{\hfill\makebox[7.0cm][l]{#1}}%

\lstset{mathescape, captionpos=b, language=AST, escapechar=\&} 
\begin{figure*}
\begin{lstlisting}
<agreement> ::= 'agreement' 'for' <prin> 'about' <asset> 'with' <policySet> 
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
<asset> ::= TheReport | ebook | latestJingle | ...
<subject> ::= Alice | Bob | ...
<act> ::= Play | Print | Display | ...
<policySet> ::= <primPolicySet> &\Comment{; primitive policy set}&
<primPolicySet> ::=
    <primInclusivePolicySet> &\Comment{; primitive inclusive policy set}&
  | <primExclusivePolicySet> &\Comment{; primitive exclusive policy set}&
<primInclusivePolicySet> ::=  
    <prerequisite> $\rightarrow$ <policy> &\Comment{; primitive inclusive policy set}&
<primExclusivePolicySet> ::=
    <prerequisite> $\mapsto$ <policy> &\Comment{; primitive exclusive policy set}&
<policy> ::=  
    'and'[ <primPolicy$_{1}$>, ..., <primPolicy$_{m}$> ] &\CommentPP{; conjunction}&
<primPolicy> ::= <prerequisite> $\Rightarrow_{<policyId>}$ <act> &\CommentPP{; primitive policy}&
<policyId> ::= N 
<prerequisite> ::=    
    'and'[ <primPrerequisite$_{1}$>, ..., 
           <primPrerequisite$_{m}$> ] &\Comment{; conjunction }&
<primPrerequisite> ::=  
    'True' &\Comment{; always true}&
  |  <constraint>	 &\Comment{; constraint}&
  |  'not' [ <constraint> ] &\Comment{; suspending constraint}&    
<constraint> ::=  
    <prin> &\Comment{; principal}&
  |  'Count' [N] &\Comment{; number of executions}&
  |  <prin> ('Count' [N]) &\Comment{; number of executions by prin}&     
\end{lstlisting}
\caption{Abstract Syntax for ACCPL}
\label{fig:agreementast}
\end{figure*}

The abstract syntax for \ac{ACCPL} is given in Figure~\ref{fig:agreementast}.The top level production is the \syn{<agreement>}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects called a principal or \syn{<prin>}, an \syn{<asset>} and a \syn{<policySet>}. Principals (\syn{<prin>}) are composed of subjects (\syn{<subject>}) which are specified based on the application e.g. \syn{Alice}, \syn{Bob}, etc. Assets and actions are also application specific such as \syn{TheReport} and \syn{ebook} for assets and \syn{Display} and \syn{Print} for actions. 

A policy set (\syn{<policySet>}) is a primitive policy set
(\syn{<primPolicySet>}), where the name is meant to signify that there
is no hierarchical nesting of policy sets. Each primitive policy set
specifies a \syn{<prerequisite>} and a \syn{<policy>}. Intuitively if
the prerequisite ``holds'' the policy is taken into
consideration. Otherwise the policy will not be looked at. Some
primitive policy sets are specified as inclusive as opposed to others
that are explicitly specified as exclusive. Primitive exclusive policy
sets are exclusive to subjects of an agreement (specified in the agreement's principal \syn{<prin>}) in that only those subjects
may perform the actions specified in the policy set. The implication
is that all other subjects who are not specified in the agreement's
principal are forbidden from performing the specified actions, no
matter whether the prerequisite holds or not. Not surprisingly, we also
define primitive inclusive policy sets that don't enforce any
exclusivity to the subjects in the agreement's principal.

A policy is made up of primitive policies. Primitive policies are
grouped together using the conjunction combining operator, specified
by the keyword \syn{and} in front of the list of the primitive
policies, which are separated by commas. A primitive policy specifies
an action to be performed on an asset, depending on whether the
policy's prerequisite holds or not. If the prerequisite holds the subjects in the
agreement's principal are permitted to perform the action on the agreement's
asset; otherwise permission is denied. A unique identifier for each
policy, called the policy identifier (\syn{<policyId>}), is included
in our definition of the policy construct in order to help the
translation (from agreements to formulas). As far as the proofs are
concerned, however, the policy identifier could be removed without a
loss to the obtained results.

A \syn{<prerequisite>} is a set of primitive prerequisites which is
closed under the conjunction operator. In \ac{ACCPL}, a
\syn{<primPrerequisite>} is either \syn{True} or it is a
\syn{<constraint>}. The \syn{True} prerequisite always holds. A
constraint is an intrinsic part of a policy and cannot be influenced
by an agreement's principal. A constraint can also be negative, specified
by the keyword \syn{not} in front of \syn{<constraint>}.

Constraints are either of the principal kind, the count kind, or the
count by principle kind. 
%***
%Principal constraints require matching to the users listed following
%the keyword \syn{<prin>}.
%Bahman, check if the sentence below is correct, and fix the rest of
%the paragraph below the ``%''.
Principal constraints require matching the list of subjects making up
the agreement's principle (\syn{<prin>}) to those in the principle (\syn{<prin>}) of the
constraint.
%
For example, the constraint of ``the only subject being Alice'' is a
constraint of the principal kind - which needs to match the agreement's principal for the action to be performed on the asset. A count constraint refers to the
number of times the user of an agreement has invoked policies to
justify her actions whereas a count by principal constraint is
concerned with how many times a principal (not the user) has invoked
the policies.  If the count constraint is part of a policy then the
count refers to that single policy. In the case that the count
constraint is part of a policy set or if the policy is a conjunction,
then the count refers to the set of policies specified in the policy
set or in the policy conjunction as the case may be.

\subsection{ACCPL Syntax in Coq}\label{sec:agreementConstructor}

\ac{ACCPL} productions were presented as high level abstract syntax in
Section~\ref{sec:productionast}. We present the corresponding
encodings in Coq in Figure~\ref{fig:agreementcoq}. Note that most of
the policy constructs are defined as inductive types using Coq's
\syn{Inductive} keyword. Also, note that the data type
\syn{nonemptylist} represents a list data structure that has at least
one element. Finally, the data types \syn{asset}, \syn{subject},
\syn{act} and \syn{policyId} are simply defined as Coq's built-in type
\syn{nat}, meaning that their elements are coded as numbers (their
definitions are omitted from the listing).

\lstset{language=Coq, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure*}
\begin{lstlisting}
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.
Definition prin := nonemptylist subject.
Inductive policySet : Set :=
  | PPS : primPolicySet -> policySet.
Inductive primPolicySet : Set :=
  | PIPS : primInclusivePolicySet -> primPolicySet
  | PEPS : primExclusivePolicySet -> primPolicySet.
Inductive primInclusivePolicySet : Set :=
  | PrimitiveInclusivePolicySet : preRequisite -> policy -> primInclusivePolicySet.
Inductive primExclusivePolicySet : Set :=
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> primExclusivePolicySet.
Inductive policy : Set :=
  | Policy : nonemptylist primPolicy -> policy.
Inductive primPolicy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> primPolicy.  
Inductive preRequisite : Set :=
  | PreRequisite : nonemptylist primPreRequisite -> preRequisite.
Inductive primPreRequisite : Set :=
  | TruePrq : primPreRequisite
  | Constraint : constraint -> primPreRequisite
  | NotCons : constraint -> primPreRequisite.
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.  
\end{lstlisting}
\caption{ACCPL: Coq Version of Agreement}
\label{fig:agreementcoq}
\end{figure*}
%\end{minipage}

%To illustrate, Figure~\ref{fig:agreementinAST} contains an example
%agreement in ACCPL expressing ``the asset TheReport may be printed a
%total of 2 times by Alice only,'' followed by
%Figures~\ref{fig:agreementincoq} and~\ref{fig:agreementincoq2}
%showing its encoding in Coq.
%
%\lstset{language=Pucella2006, captionpos=b}
%%\begin{minipage}[c]{0.95\textwidth}
%\begin{figure}
%\begin{lstlisting}
%agreement
% for Alice and Bob
% about The Report
% with True -> and[Alice, count[2]] =>$_{id1}$ print.
%\end{lstlisting}
%\caption{Example Agreement for Alice and Bob}
%\label{fig:agreementinAST}
%\end{figure}
%%\end{minipage}

To illustrate, consider the example below of an
agreement in ACCPL expressing ``the asset TheReport may be printed a
total of 2 times by Alice only.''
%
\lstset{language=Pucella2006, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
%\begin{figure}
\begin{lstlisting}
agreement
 for Alice and Bob
 about The Report
 with True -> and[Alice, count[2]] =>$_{id1}$ print.
\end{lstlisting}
%\caption{Example Agreement for Alice and Bob}
%\label{fig:agreementinAST}
%\end{figure}
%\end{minipage}
%

For purposes of comparison, the same agreement is also illustrated below using \ac{odrl}'s XML-based syntax.  %\lstset{language=XML}
\lstset{language=Pucella2006, captionpos=b}%\begin{minipage}[c]{0.95\textwidth}\begin{lstlisting}<agreement> <asset> <context> <uid> The Report </uid> </context> </asset> <permission>   <print>    <constraint> <name> Alice </name> </constraint>    <constraint> <count> 2 </count> </constraint>   </print> </permission> <party> <context> <name> Alice </name> </context> </party> <party> <context> <name> Bob </name> </context> </party></agreement>\end{lstlisting}%\caption{First Agreement for Alice and Bob in XML}%\label{fig:agreementinxml}%\end{figure}%\end{minipage} 


Figures~\ref{fig:agreementincoq} and~\ref{fig:agreementincoq2}
show the example agreement's encoding and representation, respectively, in Coq.

As shown in Figure~\ref{fig:agreementincoq}, \syn{Single} builds a Coq
list containing one element, while \syn{NewList} is the ``cons''
operator, forming a new list by adding a new element on to the front
of an existing list.  Nonempty lists can also be written as elements
separated by commas inside brackets, while regular lists (as defined in
the Coq library) can be written with a semicolon as the separator.

\lstset{language=Coq, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure*}
\begin{lstlisting}
Definition ps_xml_p1prq1:primPreRequisite := (Constraint (Principal (Single Alice))).
Definition ps_xml_p1prq2:primPreRequisite := (Constraint (Count 2)).
Definition ps_xml_prq:preRequisite := (PreRequisite (NewList ps_xml_p1prq1 (Single ps_xml_p1prq2))).
Definition ps_xml_p1:primPolicy := (PrimitivePolicy ps_xml_prq id1 Print).
Definition ps_xml_p:policy := (Policy (Single ps_xml_p1)).
Definition ps_xml:primPolicySet :=
  PIPS (PrimitiveInclusivePolicySet (makePreRequisite TruePrq) ps_xml_p).
Definition Axml := Agreement (NewList Alice (Single Bob)) TheReport (PPS ps_xml).
\end{lstlisting}
\caption{Coq Definitions for Example Agreement}
\label{fig:agreementincoq}
\end{figure*}
%\end{minipage} 

\lstset{language=Coq, captionpos=b} 
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure*}
\begin{lstlisting}
Agreement [Alice, Bob] TheReport
  (PPS
     (PIPS
        (PrimitiveInclusivePolicySet (PreRequisite [TruePrq])
           (Policy
              [PrimitivePolicy
                 (PreRequisite [Constraint (Principal [Alice]), Constraint (Count 2)]) id1 Print]))))
\end{lstlisting}
\caption{Fully Built Example Agreement in Coq}
\label{fig:agreementincoq2}
\end{figure*}
%\end{minipage} 

%%%% 125-semantics of ACCPL
\section{ACCPL Semantics}
We specify the semantics of \ac{ACCPL} as a translation function (the top level \syn{trans_agreement} function) from
an agreement together with an access request and an environment
containing all relevant facts, to decisions. In this section, we
present the access decision algorithms as high-level pseudocode. The reader is
referred to the Coq code for their concrete implementation, along with all the
auxiliary types and infrastructure which implement the semantics for
\ac{ACCPL}.


\subsection{Types of Decisions and their Implementation in Coq}\label{sec:answerandresulttypes}

As mentioned, in ACCPL, evaluating a request against a policy renders
a granted, denied or non-applicable decision. Including the non-applicable decision was
important for generality and for defining the semantics correctly.
Some policy based access-control languages use a two-valued decision,
indicating whether an access request is granted or denied. In
such languages, when a decision for a query does not evaluate to a granted decision, the design choice taken is to return an explicit deny
decision. However in this case deny stands for ``not granted''.
It is desirable to handle the case when the policy truly doesn't
specify either a granted or a deny decision. In such cases
arbitrarily returning the deny decision makes it difficult to
compose policies. To handle such cases, an explicit decision of non-applicable is desirable. Alternatively, some languages may decide
to only support granted type decisions. In such languages, the lack of a
granted decision for a query signifies a default deny decision,
and thus deny decisions are not explicit. Although the policies of
these languages may be more readable than those with more explicit
decisions, they result in ambiguity on whether a deny decision was
really intended or not. Finally, some languages define an explicit
decision of error for cases such as when both granted and
deny decisions are reached for the same query. An explicit
error decision is preferable to undefined behaviour because it can
lead to improvements to policies and/or how the queries are
built~\cite{Tschantz}. The Coq encoding of our three-valued decision
set in \ac{ACCPL} is composed of the constants \syn{Permitted},
\syn{NotPermitted} and \syn{Unregulated}.

\subsection{Translations}\label{sec:translationfuncs}

Intuitively a query or request asks the following question given an agreement: ``May subject \syn{s} perform an action \syn{ac} to asset \syn{a}?'' We represent a query by its components, namely the subject, action and asset that form the query question: \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query} in Coq. 

 
Below, we present the high-level pseudocode of the main translation algorithm (implemented in the translation functions starting with \syn{trans_agreement}).
%
Figure~\ref{fig:inclusivePS} for inclusive policy sets shows how a positive answer to a query in the form of a \syn{Permitted} decision is reached. Again, all cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown. Figure~\ref{fig:exclusivePS} for exclusive policy sets shows how a negative answer to a query in the form of a \syn{NotPermitted} decision is reached. This listing also shows that a positive decision of \syn{Permitted} is reached in exactly the same way as the case for inclusive policy sets. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown.
%\clearpage

\lstset{language=pseudo, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure}
\begin{lstlisting}
IF ($asset\_from\_query = asset\_from\_agreement$)
  IF ($subject\_from\_query$ is IN $prin\_u$)
    IF (the $preRequisite$ from the policy set HOLDS)
      IF (the $preRequisite$ from the policy HOLDS)
        IF ($action\_from\_query = action\_from\_agreement$)
            $result$ = $subject\_from\_query$
            is Permitted to perform
            $action\_from\_query$ on $asset\_from\_query$
        ELSE $result$ = Unregulated END_IF            
      ELSE $result$ = Unregulated END_IF
    ELSE $result$ = Unregulated END_IF
  ELSE $result$ = Unregulated END_IF
ELSE $result$ = Unregulated END_IF
\end{lstlisting}
\caption{Access Decision Pseudocode: Inclusive Policy Sets}
\label{fig:inclusivePS}
%\begin{minipage}[c]{0.95\textwidth}
\end{figure}
%\end{minipage}
%\clearpage
%\newpage 
\lstset{language=pseudo, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure}
\begin{lstlisting}
IF ($asset\_from\_query = asset\_from\_agreement$)
  IF ($subject\_from\_query$ is IN $prin\_u$)
    IF (the $preRequisite$ from the policy set HOLDS)
      IF (the $preRequisite$ from the policy HOLDS)
        IF ($action\_from\_query = action\_from\_agreement$)
            $result$ = $subject\_from\_query$ is Permitted to perform $action\_from\_query$ on $asset\_from\_query$
        ELSE $result$ = Unregulated END_IF            
      ELSE $result$ = Unregulated END_IF
    ELSE $result$ = Unregulated END_IF
  ELSE
    IF ($action\_from\_query = action\_from\_agreement$)
        $result$ = $subject\_from\_query$
        is NotPermitted to perform
        $action\_from\_query$ on $asset\_from\_query$
    ELSE $result$ = Unregulated END_IF
  END_IF
ELSE $result$ = Unregulated END_IF
\end{lstlisting}
\caption{Access Decision Pseudocode: Exclusive Policy Sets}
\label{fig:exclusivePS}
\end{figure}
%\end{minipage}
%%%%% 132-results chapter
%%\pagebreak
\section{Correctness of ACCPL}\label{sec:maintheorems}

In this section, we present the main theorem and some important supporting theorems, expressing the most important
properties we have proved about ACCPL. For all other supporting theorems and
for all proofs, the reader is referred to~\cite{BahPhd} and the accompanying Coq code respectively.

\subsection{Correctness of Translation}\label{sec:correct}

The \syn{trans_agreement_dec} theorem in Figure~\ref{fig:agreementdecidablecoq} is the declaration of the main correctness result for \ac{ACCPL}. Together with proofs for other theorems and lemmas, we have ``certified'' \ac{ACCPL} correct by proving this theorem. The list that \syn{trans_agreement} returns will contain results one per each primitive policy found in the agreement. Specifically the predicate \syn{isResultInQueryResult} checks for the existence of a particular result in the given list of results (definition of \syn{result} and \syn{answer} appears at the end of the listing). The theorem states that for all environments, agreements and queries (encoded in \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query}), the list that \syn{trans_agreement} produces contains either a \syn{Permitted} or a \syn{NotPermitted} result or the list will contain neither \syn{Permitted} nor \syn{NotPermitted} results.

\lstset{language=Coq, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure*}
\begin{lstlisting}
Theorem trans_agreement_dec:
  forall (e:environment) (ag:agreement) (action_from_query:act) (subject_from_query:subject)
     (asset_from_query:asset),
  (isResultInQueryResult 
     (Result Permitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)) \/
  (isResultInQueryResult 
     (Result NotPermitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)) \/
  (~(isResultInQueryResult 
     (Result Permitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\
   ~(isResultInQueryResult 
     (Result NotPermitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query))).

Inductive answer : Set := 
  | Permitted : answer 
  | Unregulated : answer
  | NotPermitted : answer.
Inductive result : Set := 
 | Result : answer -> subject -> act -> asset -> result.    
\end{lstlisting}
\caption{Agreement Translation's Correctness Property}
\label{fig:agreementdecidablecoq}
\end{figure*}
%\end{minipage}


Note that by mentioning the agreement translation function directly in the statement of the theorem in Figure~\ref{fig:agreementdecidablecoq}, we tie the correctness property to how the translation functions work. To prove the theorem and with each successive subgoal during the interactive proof process, the definition of the translation function in scope gets unfolded and used so the translation functions have to be defined such that each subgoal is discharged and the proof is completed. 


As an example and also a visual aid to understanding how queries are
answered, see Figure~\ref{fig:permittedcoq}.
%
\lstset{language=Coq, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure*}
\begin{lstlisting}
isResultInQueryResult (Result Permitted Alice Print ebook)
  [(Result Unregulated Alice Print ebook); (Result Unregulated Alice Print ebook);
   (Result Permitted Alice Print ebook)]
\end{lstlisting}
\caption{Access Request Resulting in Decision of \syn{Permitted}}
\label{fig:permittedcoq}
\end{figure*}
%\end{minipage}
The \syn{isResultInQueryResult} predicate looks for a result with an
answer of \syn{Permitted} in the list that \syn{trans_agreement} has
produced, for an agreement for three primitive policies (since the set
contains three results). In words, we are asking whether Alice is
allowed to print the asset ebook, given a policy.
    
According to the theorem in Figure~\ref{fig:agreementdecidablecoq} we have three mutually exclusive cases. The first case is when the set has a at least one \syn{Permitted} result; we answer the access query in this case with a result of \syn{Permitted}. (This would be the case in the Figure~\ref{fig:permittedcoq}.) The second case is when the set has at least one \syn{NotPermitted}; we answer the access query in this case with a result of \syn{NotPermitted}. In the case where all the results are \syn{Unregulated} we answer the access query with a result of \syn{Unregulated}. We show this case indirectly in the theorem in Figure~\ref{fig:agreementdecidablecoq} by stating the set does not contain a \syn{Permitted} result nor a \syn{NotPermitted} result. 

\subsection{Mutual Exclusivity of \syn{Permitted} and \syn{NotPermitted}}\label{sec:mutualexclusive}

The proof of the theorem in
Figure~\ref{fig:permandnotpermmutualexclusive} establishes that both
\syn{Permitted} and \syn{NotPermitted} results cannot exist in the
same set returned by \syn{trans_agreement}. This result also
establishes the fact that in \ac{ACCPL} rendering conflicting
decisions is not possible given an agreement.

\lstset{language=Coq, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure*}
\begin{lstlisting}
Theorem trans_agreement_not_Perm_and_NotPerm_at_once:
  forall (e:environment) (ag:agreement) (action_from_query:act) (subject_from_query:subject)
     (asset_from_query:asset),
  ~((isResultInQueryResult 
      (Result Permitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\
    (isResultInQueryResult 
      (Result NotPermitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query))).
\end{lstlisting}
\caption{\syn{Permitted} and \syn{NotPermitted}: Mutually Exclusive}
\label{fig:permandnotpermmutualexclusive}
\end{figure*}
%\end{minipage}

The proof of the theorem in
Figure~\ref{fig:notpermandnotpermimpliesunregulated} shows that in
the case where neither a \syn{Permitted} nor a \syn{NotPermitted}
result exists in the set returned by \syn{trans_agreement}, there must
exist at least one \syn{Unregulated} result.

\lstset{language=Coq, captionpos=b}
%\begin{minipage}[c]{0.95\textwidth}
\begin{figure*}
\begin{lstlisting}
Theorem trans_agreement_not_NotPerm_and_not_Perm_implies_Unregulated_dec:
  forall (e:environment) (ag:agreement) (action_from_query:act) (subject_from_query:subject)
     (asset_from_query:asset),
  (~(isResultInQueryResult 
     (Result Permitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\
   ~(isResultInQueryResult 
     (Result NotPermitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query))) ->
  (isResultInQueryResult 
     (Result Unregulated subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)).
\end{lstlisting}
\caption{(Not \syn{Permitted} and Not \syn{NotPermitted}) Implies \syn{Unregulated}}
\label{fig:notpermandnotpermimpliesunregulated}
\end{figure*}
%\end{minipage}


\section{Related Work}
We review here related work and approaches to defining semantics for
\ac{pbac} based languages.
 
%\subsection{Lithium}
As mentioned, Halpern and Weissman~\cite{Halpern2008} use \ac{fol} to represent and reason about policies; policies describe the conditions under which a request to perform an action, such as reading a file, is granted or denied. They restrict \ac{fol} to get tractability for answering the query of whether a request to access a resource may be granted or denied, given a policy, and argue that despite the tractability results their language is still expressive. The authors focus on satisfying three requirements in the design of their language Lithium: expressive enough, tractable enough and usable by non-experts.

Holzer et al.~\cite{Holzer} give a semantics for \ac{odrl} that models the actions that are allowed according to a contract or an agreement. This model is presented in terms of automata. Each trace through the automaton represents a valid sequence of actions for each participant. The states of the automaton encode the state of the license at each point in time, meaning, which actions are allowed at what point considering the actions that have taken place in the past. 

%\subsection{Operational Semantics}
%Sheppard and Safavi-Naini~\cite{SheppardS09} propose an operational model for both formalizing and enforcing digital rights using a \emph{right expression compiler}. They use their model to develop operational semantics for \ac{oma}, from which an interpreter could be derived. 

%\subsection{Conflict Detection Algorithms}
Capretta, et al.~\cite{CaprettaSFM07} present a conflict detection algorithm for the Cisco firewall specification~\cite{ciscofirewall} and formalize a correctness proof for it in the Coq proof assistant. The authors present their algorithm in Coq's functional programming language along with access rules and requests which are also encoded in Coq. The authors also prove in~\cite{CaprettaSFM07} that their algorithm finds all conflicts and only the correct conflicts in a set of rules. The algorithm is therefore verified formally to be both sound and complete.

Extending the above work, St-Martin and Felty~\cite{felty16} represent
policies for a fragment of \ac{xacml} 3.0 in the Coq proof assistant,
propose an algorithm for detecting all conflicts in \ac{xacml}
policies, and prove it correct. Their \ac{xacml} subset includes some
complex conditions such as time constraints. The policy language and
thus the conflict detection algorithm for XACML is much more complex
than the one for Cisco firewalls, and resulted in having to consider
many cases including many subtle corner cases.

\section{Future Work}


Our results subsume the above results on conflict detection in the
sense that for \ac{ACCPL}, we have formally proven that conflicts are
not possible. This is an important aspect of our small certified core
language, but as this core is extended to cover more of the expressive
power of existing policy languages, this property will likely no
longer hold. By starting with a conflict-free core, our goal is to
keep conflict detection as simple as possible as we add more features.

%***
% This paragraph is repetitious now that these properties are
% mentioned in the introduction.  I modified it.
%Tschantz and Krishnamurthi~\cite{Tschantz} argue for the need for formal means to compare and contrast \ac{pbac} languages with respect to a set of common ``reasonability properties''. We describe in~\cite{BahPhd} why \ac{ACCPL} is deterministic, total, safe, has independent composition property and supports a monotonic policy combinator (Tschantz and Krishnamurthi's reasonability properties). However, we have not yet certified (using formal proofs) that \ac{ACCPL} has these properties. We defer formally proving these properties for \ac{ACCPL} as future work. 
We describe in~\cite{BahPhd} how \ac{ACCPL} meets the reasonability
properties of Tschantz and Krishnamurthi~\cite{Tschantz} mentioned
earlier.  However, we have not yet certified (using formal proofs)
that \ac{ACCPL} has these properties. We defer formally proving these
properties for \ac{ACCPL} as future work.

Another direction for future work is to explore different ways \ac{ACCPL} could be made more expressive. For example, we can add various policy combinators and their semantics to \ac{ACCPL} using the Translation Function Framework (TFF). As mentioned earlier, the TFF we have developed for \ac{ACCPL} is meant to keep the delicate balance between addition of expressiveness while maintaining provability of established results.

Another design goal for \ac{ACCPL} was to make it a target language for deploying policies written in other languages. We could capture, implement and study the semantics of these other policy-based access-control systems using the TFF and ultimately certify the semantics of those languages with respect to their specifications the same way \ac{ACCPL} has been certified correct. 
%For example, we can take another \ac{pbac} system such as \ac{xrml} and \ac{odrl}, implement them in Coq as additional or (modifications of) existing \ac{ACCPL} constructs, analyze and reason about them, etc. 
%
In fact, our current work includes extending ACCPL to handle the
expressive power of SELinux~\cite{EamanSistanyFelty:MCETECH17}.

\section{Conclusion}
We have presented the design and implementation of \ac{ACCPL} as a small and certifiably correct policy language. \ac{ACCPL} is a \ac{pbac} system that can be used to express general access-control rules and policies. In addition we have defined formal semantics for \ac{ACCPL} where we have discovered and added all possible cases when answering a query on whether to allow or deny an action to be performed on an asset. We have subsequently used the Coq Proof Assistant to state theorems about the expected behavior of \ac{ACCPL} when evaluating a request with respect to a given policy, to develop proofs for those theorems and to machine-check the proofs ensuring correctness guarantees are provided. We have in particular stated, developed and proved correctness results for the semantics of \ac{ACCPL}. 

%Additionally, we have described why certain design choices were made and how they contributed to the ease of reasoning for \ac{ACCPL}. Admittedly some expressive power present in other access-control policy languages was omitted from \ac{ACCPL} in order to achieve the reported correctness proofs. For example, in \ac{ACCPL} we only support base policy sets (policy sets that are not composed of other policy sets) i.e., no combining of base policy sets using conjunctions or other combining operators are supported.

%\section*{Acknowledgment}

% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtranS}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{pst2017}
%


\end{document}


