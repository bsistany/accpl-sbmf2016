%"runningheads" enables:
%  - page number on page 2 onwards
%  - title/authors on even/odd pages
%This is good for other readers to enable proper archiving among other papers and pointing to content.
%Even if the title page states the title, when printed and stored in a folder, when blindly opening the folder, one could hit not the title page, but an arbitrary page. Therefore, it is good to have title printed on the pages, too.
\documentclass[runningheads,a4paper]{llncs}

%Even though `american`, `english` and `USenglish` are synonyms for babel package (according to https://tex.stackexchange.com/questions/12775/babel-english-american-usenglish), the llncs document class is prepared to avoid the overriding of certain names (such as "Abstract." -> "Abstract" or "Fig." -> "Figure") when using `english`, but not when using the other 2.
\usepackage[english]{babel}


%better font, similar to the default springer font
%cfr-lm is preferred over lmodern. Reasoning at http://tex.stackexchange.com/a/247543/9075
\usepackage[%
rm={oldstyle=false,proportional=true},%
sf={oldstyle=false,proportional=true},%
tt={oldstyle=false,proportional=true,variable=true},%
qt=false%
]{cfr-lm}
%
%if more space is needed, exchange cfr-lm by mathptmx
%\usepackage{mathptmx}

\usepackage{graphicx}

%extended enumerate, such as \begin{compactenum}
\usepackage{paralist}

%put figures inside a text
%\usepackage{picins}
%use
%\piccaptioninside
%\piccaption{...}
%\parpic[r]{\includegraphics ...}
%Text...

%Sorts the citations in the brackets
%\usepackage{cite}

\usepackage[T1]{fontenc}

%for demonstration purposes only
\usepackage[math]{blindtext}

%for easy quotations: \enquote{text}
\usepackage{csquotes}

%enable margin kerning
\usepackage{microtype}

%tweak \url{...}
\usepackage{url}
\usepackage[section]{algorithm}
\usepackage{algorithmic}
\usepackage{fancybox}
%\usepackage[]{algorithm2e}
%\usepackage{algpseudocode}
%nicer // - solution by http://tex.stackexchange.com/a/98470/9075
\makeatletter
\def\Url@twoslashes{\mathchar`\/\@ifnextchar/{\kern-.2em}{}}
\g@addto@macro\UrlSpecials{\do\/{\Url@twoslashes}}
\makeatother
\urlstyle{same}
%improve wrapping of URLs - hint by http://tex.stackexchange.com/a/10419/9075
\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother

%diagonal lines in a table - http://tex.stackexchange.com/questions/17745/diagonal-lines-in-table-cell
%slashbox is not available in texlive (due to licensing) and also gives bad results. This, we use diagbox
%\usepackage{diagbox}

%required for pdfcomment later
\usepackage{xcolor}

% new packages BEFORE hyperref
% See also http://tex.stackexchange.com/questions/1863/which-packages-should-be-loaded-after-hyperref-instead-of-before

%enable hyperref without colors and without bookmarks
\usepackage[
%pdfauthor={},
%pdfsubject={},
%pdftitle={},
%pdfkeywords={},
bookmarks=false,
breaklinks=true,
colorlinks=true,
linkcolor=black,
citecolor=black,
urlcolor=black,
%pdfstartpage=19,
pdfpagelayout=SinglePage,
pdfstartview=Fit
]{hyperref}
%enables correct jumping to figures when referencing
\usepackage[all]{hypcap}

%enable nice comments
\usepackage{pdfcomment}
\newcommand{\commentontext}[2]{\colorbox{yellow!60}{#1}\pdfcomment[color={0.234 0.867 0.211},hoffset=-6pt,voffset=10pt,opacity=0.5]{#2}}
\newcommand{\commentatside}[1]{\pdfcomment[color={0.045 0.278 0.643},icon=Note]{#1}}

%compatibality with TODO package
\newcommand{\todo}[1]{\commentatside{#1}}

%enable \cref{...} and \Cref{...} instead of \ref: Type of reference included in the link
\usepackage[capitalise,nameinlink]{cleveref}
%Nice formats for \cref
\crefname{section}{Sect.}{Sect.}
\Crefname{section}{Section}{Sections}

\usepackage{xspace}
%\newcommand{\eg}{e.\,g.\xspace}
%\newcommand{\ie}{i.\,e.\xspace}
\newcommand{\eg}{e.\,g.,\ }
\newcommand{\ie}{i.\,e.,\ }

\newcommand{\syn}{\texttt}

%%%%%% Languages
\usepackage{listings,lstautogobble}
\usepackage{syntax}
%\usepackage{lstcoq}
\usepackage{url}




\newcommand{\notimplies}{%
  \mathrel{{\ooalign{\hidewidth$\not\phantom{=}$\hidewidth\cr$\implies$}}}}

\newcommand{\algCaption}[1]{
    \caption{#1}
    \addcontentsline{lol}{lstlisting}{\protect\numberline{\thealgorithm}#1}
    \addtocounter{lstlisting}{1}}
\AtBeginEnvironment{lstlisting}{\addtocounter{algorithm}{1}}



\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily,
  frame=single,
  breaklines=true,
  morestring=[s]{"}{"},
  morecomment=[s]{?}{?},
  morecomment=[s]{!--}{--},
  commentstyle=\color{black},
  moredelim=[s][\color{black}]{>}{<},
  moredelim=[s][\color{black}]{\ }{=},
  stringstyle=\color{black},
  identifierstyle=\color{black},
  autogobble=true
}
\lstdefinelanguage{pseudo}
{
  morekeywords={
    IF, THEN, ELSE, END_IF, HOLDS, Permitted, NotPermitted, Unregulated, IN
  }
}
\lstdefinelanguage{Pucella2006}
{
  morekeywords={
    agreement, prin, asset, with, prePay, and, display, print, count
  }
}
\lstdefinelanguage{selinux}
{
  morekeywords={
    type, types, attrib, role, allow, user, constrain, avkind, 
	sourcetype, targettype, object-class, perm, allow, auditallow, dontaudit, neverallow,
	constrain, classes, perms, sourcetype, sourcerole, sourceuser, targettype, targetrole, targetuser
  }
}

\lstdefinelanguage{AST}
{
  basicstyle=\ttfamily,
  breaklines=true,
  morekeywords=[1]{
    prin, asset, subject, act, 
    policySet, primPolicySet, primExclusivePolicySet, primExclusivePolicySet, primInclusivePolicySet, primPolicy, 
    policy, policyId, primPrerequisite, prerequisite, constraint, agreement
  },
  tabsize=1,
}

\newtheorem{innercustomthm}{Theorem}
\newenvironment{customthm}[1]
  {\renewcommand\theinnercustomthm{#1}\innercustomthm}
  {\endinnercustomthm}


%%%%%% Languages

%introduce \powerset - hint by http://matheplanet.com/matheplanet/nuke/html/viewtopic.php?topic=136492&post_id=997377
\DeclareFontFamily{U}{MnSymbolC}{}
\DeclareSymbolFont{MnSyC}{U}{MnSymbolC}{m}{n}
\DeclareFontShape{U}{MnSymbolC}{m}{n}{
    <-6>  MnSymbolC5
   <6-7>  MnSymbolC6
   <7-8>  MnSymbolC7
   <8-9>  MnSymbolC8
   <9-10> MnSymbolC9
  <10-12> MnSymbolC10
  <12->   MnSymbolC12%
}{}
\DeclareMathSymbol{\powerset}{\mathord}{MnSyC}{180}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage{acro}

\input{list-of-acronyms}

%\usepackage{refcheck}

\begin{document}
%\lstset{aboveskip=0pt, belowskip=2pt}

%Works on MiKTeX only
%hint by http://goemonx.blogspot.de/2012/01/pdflatex-ligaturen-und-copynpaste.html
%also http://tex.stackexchange.com/questions/4397/make-ligatures-in-linux-libertine-copyable-and-searchable
%This allows a copy'n'paste of the text from the paper
\input glyphtounicode.tex
\pdfgentounicode=1

\title{A Certified Core Policy Language}
%If Title is too long, use \titlerunning
%\titlerunning{Short Title}

%Single insitute
\author{Bahman Sistany\inst{1,2} \and Amy Felty\inst{1}}
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}
\institute{School of Electrical Engineering and Computer Science\\
  University of Ottawa, Ottawa, Canada
\and
Irdeto Canada Corporation, Ottawa, Canada\\
  \email{bahman.sistany@irdeto.com}, \email{afelty@uottawa.ca}
}

%Multiple insitutes
%Currently disabled
%
\iffalse
%Multiple institutes are typeset as follows:
\author{Firstname Lastname\inst{1} \and Firstname Lastname\inst{2} }
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}

\institute{
Insitute 1\\
\email{...}\and
Insitute 2\\
\email{...}
}
\fi
			
\maketitle

\begin{abstract}
%We present the design and implementation of a Certified Core Policy Language (ACCPL) that can be used to express access-control policies. We define formal semantics for ACCPL where we discover and enumerate all possible cases when answering an access query. We use the Coq Proof Assistant to state theorems about the semantics of ACCPL, to develop proofs for those theorems and to machine-check the proofs ensuring correctness guarantees are provided. The main design goal for ACCPL is the ability to reason about the policies written in ACCPL with respect to specific questions. In addition ACCPL is designed to be extendable so that extensions to expressive power may be explored with respect to the established reasonability properties.  To this end, ACCPL is small (the syntax and the semantics of ACCPL only take a few pages to describe), although we believe ACCPL supports the core features of access-control policy languages.
We present the design and implementation of a Certified Core Policy
Language (ACCPL) that can be used to express access-control policies.
We define formal semantics for ACCPL and use the Coq Proof Assistant
to state theorems about this semantics, to develop proofs for those
theorems and to machine-check the proofs ensuring correctness
guarantees are provided. The main design goal for ACCPL is the ability
to reason about the policies written in ACCPL with respect to specific
questions. In addition ACCPL is designed to be extendable so that
extensions to expressive power may be explored with respect to the
established correctness properties.  To this end, ACCPL is small (the
syntax and the semantics of ACCPL only take a few pages to describe),
although we believe ACCPL supports the core features of access-control
policy languages.
\end{abstract}

\keywords{program correctness, formal verification, access control,
policy analysis, Coq, XACML, DRM, ODRL, SELinux}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:intro}
We describe the design of a \ac{ACCPL} 
% new phrase
for expressing access control policies
%
and its implementation in the
Coq Proof Assistant. Using Coq to implement \ac{ACCPL} was an
important factor in its design, allowing us to address the trade-off
between expressive power and ease of formal proof of correctness.
The semantics of \ac{ACCPL} are specified by translation from policy
statements together with an access request and an environment
containing all the relevant facts, to decisions. We present results
showing the translation functions behave correctly with respect to the
decision question that asks whether a request to access a resource may
be granted or denied, given a policy. The translation functions also
cover the case where a given policy does not apply to a request in
which case a decision of non-applicable is rendered. Our results show
that for each access request, the translation algorithm terminates on
all input policies with a decision of granted, denied or
non-applicable.
To motivate the design of \ac{ACCPL}, let us review the definition of
``access-control'': Authorization refers to the process of rendering a
decision about whether to permit or deny access to a resource or asset
of interest, hence the term ``access-control.''

Although various access-control models exist, to harmonize access control in large environments with many subjects and objects and disparate attributes, the \ac{pbac}~\cite{nist} model has been proposed. \ac{pbac} allows for a uniform and central access-control model among the various organizational units. There is also a need for large organizations to put in place mechanisms so that access-control rules can be easily audited. This calls for a data-driven approach to access-control where the data, in this case the access-control rules, are available to read and analyze. 


Because of the cited advantages, along with its generality and
widespread use, \ac{pbac} is the model \ac{ACCPL} implements.

\subsection{A Core Policy Language for PBAC Systems} 

Currently, the most popular \ac{rel}s include the
\ac{xrml}~\cite{Wang}, and \ac{odrl}~\cite{odrloneone}. Both of these
languages are XML based and are considered declarative
languages. \ac{rel}s, or more precisely \ac{drel}s deal with the ``rights
definition'' aspect of the \ac{drm} ecosystem of digital assets. 
A \ac{drel}, allows the expression and definition
of digital asset usage rights so that other areas of the \ac{drm}
ecosystem, namely the enforcement mechanism and the usage tracking
components can function correctly.

\ac{drm} refers to the digital management of rights associated with
the access or usage of digital assets. There are various aspects of
rights management however.
According to Collier et.\ al.\ in their white paper~\cite{collier},
%
digital rights management systems comprise these categories: defining
rights, distributing/acquiring rights, enforcing rights and finally
tracking usage.


The \ac{xacml}~\cite{xacml3} is another access control policy
specification language that is general, high-level, and allows
policies to be defined in a wide variety of domains.  It is an OASIS
standard that is becoming more widely used.  Like \ac{odrl} and
\ac{xrml}, it is based on XML and the \ac{pbac} model.  \ac{odrl} and
\ac{xrml} differ from \ac{xacml} by their focus on digital assets
protection and in general \ac{drm}, hence the term \ac{drel}.  Despite
this difference, \ac{drel}s and specifically \ac{odrl} are used to
arbitrate access to assets under conditions which is very similar to
how access control conditions are expressed in access control policy
languages such as \ac{xacml} and even \ac{selinux}~\cite{selinux}. In
fact several authors have worked on interoperability between \ac{rel}s
and access control policy languages, specifically between \ac{odrl}
and
\ac{xacml}~\cite{prados2005interoperability,maronas2009architecture}.


For a variety of reasons, we found \ac{xacml}, \ac{odrl} and \ac{xrml}
all to be ill-suited as the basis for a core policy language.  First,
they are all large languages that provide numerous features but suffer
from a lack of formal semantics. For example, the \ac{xacml} standard
is written in prose and contains quite a number of loose points that
may give rise to different interpretations and lead to different
implementation choices~\cite{DBLP:conf/essos/MasiPT12}.  Second, all
of these languages cover much more than policy expressions leading to
access decisions; they also address enforcement of policies (\ac{odrl}
and \ac{xrml} specifically and \ac{drm} in general distinguish
themselves from general access-control languages by additionally
addressing enforcement of policies beyond where the policies were
generated). Third, they are limited in terms of what can be built on
top of them; for example expressing hierarchical role-based
access-control in \ac{xacml} requires a fairly complex
encoding~\cite{Tschantz}.


A policy language based on logic and formal semantics but one that was small and extendible was needed. We use Pucella and Weissman's subset of \ac{odrl}~\cite{pucella2006} as the starting point for \ac{ACCPL} and in doing so treat digital rights as our main access-control application without loss of generality with respect to other applications, with the final goal of performing formal verification on policies written in \ac{ACCPL}.



%----------------------------------------------------------------------
\subsection{Formal Semantics for PBAC Languages}
%----------------------------------------------------------------------


Formal methods help ensure that a system behaves correctly with respect to a specification of its desired behaviour~\cite{TAPL}. This specification of the desired behaviour is what's referred to as \emph{semantics} of the system. Using formal methods requires defining precise and formal semantics, without which analysis and reasoning about properties of the system in question would become impossible. To formalize the semantics of \ac{pbac} languages several approaches have been attempted by various authors. Most are logic based~\cite{Halpern2008,pucella2006} while others are based on finite-automata~\cite{Holzer}, operational semantics based interpreters~\cite{Safavi-naini} and web ontology (from the Knowledge Representation Field)~\cite{Kasten2010MTS}. 




\subsection{Specific Problem}

Policy languages and the policies, sometimes called \emph{agreements}, written in those languages are meant to implement specific goals such as limiting access to specific assets. The tension in designing a policy language is usually between how to make the language expressive enough, such that the design goals for the policy language may be expressed, and how to make the policies verifiable with respect to the stated goals.

As stated earlier, an important part of fulfilling the verifiability goal is to have formal semantics defined for policy languages. For \ac{odrl}, authors of~\cite{pucella2006} define a formal semantics based on which they declare and prove a number of important theorems (their main focus is on stating and proving algorithm complexity results). However as with many paper-proofs, the language used to do the proofs while mathematical in nature, uses many intuitive justifications. As such these proofs are difficult to verify or to ``derive.'' Furthermore the proofs can not be used directly to render a decision on a sample policy (e.g. whether to allow or deny access to an asset). Of course one may (carefully) construct a program based on these proofs for practical purposes but certifying such programs correct presents additional verification challenges, even assuming the original proofs were in fact correct.

\subsection{Contributions}\label{sec:contribs}

We have designed a policy based access-control language called \ac{ACCPL} based on \ac{odrl} and starting with definitions in~\cite{pucella2006}. The \ac{ACCPL} framework has been encoded in \emph{Coq}~\cite{BC04} which is both a programming language and a proof-assistant. We have specified and proved \ac{ACCPL} correct with respect to properties of interest in Coq which will allow us to extract programs from the proofs; the executable programs can be used on specific policies and a query, to render a specific decision such as ``a permission has been granted.'' 

We originally started with a specific subset of~\cite{pucella2006} so that we could concentrate on what we believed to be the essence or core of the language. Initially we intended to maintain the central semantic definitions including ``Closed World Assumptions''~\cite{pucella2006} where the semantics only specify explicitly \syn{Permitted} and \syn{NotPermitted} answers; we discovered, however, that the semantics as stated by Pucella and Weissman~\cite{pucella2006} are not explicit and therefore the decision question that asks whether a request to access a resource may be granted or denied, may not be answered in all cases. We have therefore made major modifications to the semantics of Pucella and Weissman's language such that an answer to a request for access to a resource may be determined unambiguously and for all cases. 
%
Specifically, to consider all cases, our program evaluates a request
against each subpolicy of an agreement and returns one result for
each.  The overall result is a list of decisions.  We define what it
means to extract a single decision from a list of decisions and show
that it is always possible to extract a \emph{coherent} decision.  The
definitions and theorems required to express this notion of
correctness are detailed in Section~\ref{sec:maintheorems}.


Given that \ac{ACCPL} is a core policy language with semantics that have been certified correct, we could use \ac{ACCPL} to implement various (more expressive) policy languages. In addition \ac{ACCPL} could be used as an intermediate language to reason about interoperability between those policy languages~\cite{prados2005interoperability,maronas2009architecture}. In this manner our language \ac{ACCPL} can be viewed as an extendable language, complete with defined and verified semantics, that can be used as the basis for implementing various policy languages with more expressive power (e.g. W3C's \ac{odrl} and \ac{selinux}). 

For access to the Coq source code for \ac{ACCPL}, please refer to \url{http://www.site.uottawa.ca/~afelty/accpl/}.

\section{ACCPL Syntax}
%% Coq Syntax chapter

We follow the style of~\cite{pucella2006} by using abstract syntax to express policy statements in \ac{ACCPL}. 

\subsection{Environmental Facts}\label{sec:odrl0}
To determine the outcome of requests evaluated against policies,
specified conditions in those policies must be evaluated with respect
to environmental facts. In the \ac{drm} realm with its focus on usage
control, the kinds of facts that are typically tracked in the
environment include a count of how many times an asset has been
accessed, the amount a user has paid to access an asset, and whether a
user has made an attribution (e.g. mentioning the content owner by
name). In \ac{ACCPL}, agreements and facts (i.e. environments) will
refer to a count of how many times each policy should be used and has
been used respectively, to justify an action.
Although our core language includes only one kind of fact, extending
it to other kinds is straightforward.

\subsection{Abstract Syntax for ACCPL} \label{sec:productionast}

The abstract syntax for \ac{ACCPL} is given in Listing~\ref{lst:agreementast}. 
\newcommand*{\Comment}[1]{\hfill\makebox[5.0cm][l]{#1}}%
\newcommand*{\CommentPP}[1]{\hfill\makebox[3.0cm][l]{#1}}%
\renewcommand{\thelstlisting}{\thesection-\arabic{lstlisting}}%
% agreement
\lstset{mathescape, language=AST, escapechar=\&} 
%\begin{minipage}[c]{0.95\textwidth}
% order of elements changed so that every construct appears after it
% is mentioned in a previous construct
\begin{lstlisting}[frame=single, caption={Abstract Syntax for ACCPL},label={lst:agreementast}]
<agreement> ::= 
  'agreement' 'for' <prin> 'about' <asset> 'with'
  <policySet> 
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
<asset> ::= TheReport | ebook | latestJingle | ...
<subject> ::= Alice | Bob | ...
<act> ::= Play | Print | Display | ...
<policySet> ::=  
  <primPolicySet> &\Comment{; primitive policy set}&
<primPolicySet> ::=  
  <primInclusivePolicySet> &\Comment{; primitive inclusive policy set}&
| <primExclusivePolicySet> &\Comment{; primitive exclusive policy set}&
<primInclusivePolicySet> ::=  
  <prerequisite> $\rightarrow$ <policy> &\Comment{; primitive inclusive policy set}&
<primExclusivePolicySet> ::=  
  <prerequisite> $\mapsto$ <policy> &\Comment{; primitive exclusive policy set}&
<policy> ::=  
  'and'[ <primPolicy$_{1}$>, ..., 
         <primPolicy$_{m}$> ] &\CommentPP{; conjunction}&
<primPolicy> ::=  
  <prerequisite> $\Rightarrow_{<policyId>}$ <act> &\CommentPP{; primitive policy}&
<policyId> ::= N 
<prerequisite> ::=    
  'and'[ <primPrerequisite$_{1}$>, ..., 
         <primPrerequisite$_{m}$> ] &\Comment{; conjunction }&
<primPrerequisite> ::=  
  'True' &\Comment{; always true}&
|  <constraint>	 &\Comment{; constraint}&
|  'not' [ <constraint> ] &\Comment{; suspending constraint}&    
<constraint> ::=  
  <prin> &\Comment{; principal}&
|  'Count' [N] &\Comment{; number of executions}&
|  <prin> ('Count' [N]) &\Comment{; number of executions by prin}&     
\end{lstlisting}
%\end{minipage} 
The top level production is the \syn{<agreement>}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects called a principal or \syn{<prin>}, an \syn{<asset>} and a \syn{<policySet>}. Principals (\syn{<prin>}) are composed of subjects (\syn{<subject>}) which are specified based on the application e.g. \syn{Alice}, \syn{Bob}, etc. Assets and actions are also application specific such as \syn{TheReport} and \syn{ebook} for assets and \syn{Display} and \syn{Print} for actions. 

A policy set (\syn{<policySet>}) is a primitive policy set
(\syn{<primPolicySet>}), where the name is meant to signify that there
is no hierarchical nesting of policy sets. Each primitive policy set
specifies a \syn{<prerequisite>} and a \syn{<policy>}. Intuitively if
the prerequisite ``holds'' the policy is taken into
consideration. Otherwise the policy will not be looked at. Some
primitive policy sets are specified as inclusive as opposed to others
that are explicitly specified as exclusive. Primitive exclusive policy
sets are exclusive to an agreement's users in that only those users
may perform the actions specified in the policy set. The implication
is that all other users who are not specified in the agreement's
principal are forbidden from performing the specified actions, no
matter whether the prerequisite holds or not. Not surprisingly, we also
define primitive inclusive policy sets that don't enforce any
exclusivity to the agreement's users.

A policy is made up of primitive policies. Primitive policies are
grouped together using the conjunction combining operator, specified
by the keyword \syn{and} in front of the list of the primitive
policies, which are separated by commas.  A primitive policy specifies
an action to be performed on an asset, depending on whether the
policy's prerequisite holds or not. If the prerequisite holds the
agreement's user is permitted to perform the action on the agreement's
asset; otherwise permission is denied. A unique identifier for each
policy, called the policy identifier (\syn{<policyId>}), is included
in our definition of the policy construct in order to to help the
translation (from agreements to formulas).  As far as the proofs are
concerned, however, the policy identifier could be removed without a
loss to the obtained results.

A \syn{<prerequisite>} is a set of primitive prerequisites which is
closed under the conjunction operator.  In \ac{ACCPL}, a
\syn{<primPrerequisite>} is either \syn{True} or it is a
\syn{<constraint>}. The \syn{True} prerequisite always holds. A
constraint is an intrinsic part of a policy and cannot be influenced
by an agreement's users. A constraint can also be negative, specified
by the keyword \syn{not} in front of \syn{<constraint>}.

Constraints are either of the principal kind, the count kind, or the
count by principle kind. Principal constraints require matching to the users listed following the keyword \syn{<prin>}. For example, the
constraint of ``the user being Alice'' is a constraint of the
principal kind. A count constraint refers to the number of times the
user of an agreement has invoked policies to justify her actions whereas a count by principal constraint is concerned with how many times a principal (not the user) has invoked the policies. 
If the count constraint is part of a policy then the count refers to that
single policy. In the case that the count constraint is part of a
policy set or if the policy is a conjunction, then the count refers to
the set of policies specified in the policy set or in the policy
conjunction as the case may be.

\subsection{ACCPL Syntax in Coq}\label{sec:agreementConstructor}

\ac{ACCPL} productions were presented as high level abstract syntax in
Section~\ref{sec:productionast}. We present the corresponding
encodings in Coq in Listing~\ref{lst:agreementcoq}. Note that most of
the policy constructs are defined as inductive types using Coq's
\syn{Inductive} keyword. Also, note that the data type
\syn{nonemptylist} represents a list data structure that has at least
one element.  Finally, the data types \syn{asset}, \syn{subject},
\syn{act} and \syn{policyId} are simply defined as Coq's built-in type
\syn{nat}, meaning that their elements are coded as numbers. (Their
definitions are omitted from the listing.)

\lstset{language=Coq}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={ACCPL: Coq Version of Agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
 | Agreement : prin -> asset -> policySet -> agreement.
Definition prin := nonemptylist subject.
Inductive policySet : Set :=
 | PPS : primPolicySet -> policySet.
Inductive primPolicySet : Set :=
 | PIPS : primInclusivePolicySet -> primPolicySet
 | PEPS : primExclusivePolicySet -> primPolicySet.
Inductive primInclusivePolicySet : Set :=
 | PrimitiveInclusivePolicySet : preRequisite -> policy -> primInclusivePolicySet.
Inductive primExclusivePolicySet : Set :=
 | PrimitiveExclusivePolicySet : preRequisite -> policy  -> primExclusivePolicySet.
Inductive policy : Set :=
 | Policy : nonemptylist primPolicy -> policy.
Inductive primPolicy : Set :=
 | PrimitivePolicy : preRequisite -> policyId -> act -> primPolicy.  
Inductive preRequisite : Set :=
 | PreRequisite : nonemptylist primPreRequisite -> preRequisite.
Inductive primPreRequisite : Set :=
 | TruePrq : primPreRequisite
 | Constraint : constraint -> primPreRequisite
 | NotCons : constraint -> primPreRequisite.
Inductive constraint : Set :=
 | Principal : prin  -> constraint 
 | Count : nat -> constraint 
 | CountByPrin : prin -> nat -> constraint.  
\end{lstlisting}
%\end{minipage}

To illustrate, Listing~\ref{lst:agreementinAST} contains an example
agreement in ACCPL expressing ``the asset TheReport may be printed a
total of 2 times by Alice only,'' followed by
Listings~\ref{lst:agreementincoq} and~\ref{lst:agreementincoq2}
showing its encoding in Coq.

\lstset{language=Pucella2006}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Example Agreement for Alice and Bob}, label={lst:agreementinAST}, mathescape]
agreement
 for Alice and Bob
 about The Report
 with True -> and[Alice, count[2]] =>$_{id1}$ print.
\end{lstlisting}
%\end{minipage}

\lstset{language=Coq, frame=single, caption={Coq Definitions for Example Agreement}, label={lst:agreementincoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition ps_xml_p1prq1:primPreRequisite := 
  (Constraint (Principal (Single Alice))).
Definition ps_xml_p1prq2:primPreRequisite := 
  (Constraint (Count 2)).
Definition ps_xml_prq:preRequisite := 
  (PreRequisite (NewList ps_xml_p1prq1 (Single ps_xml_p1prq2))).
Definition ps_xml_p1:primPolicy := 
  (PrimitivePolicy ps_xml_prq id1 Print).
Definition ps_xml_p:policy := 
  (Policy (Single ps_xml_p1)).
Definition ps_xml:primPolicySet :=
  PIPS (PrimitiveInclusivePolicySet
    (makePreRequisite TruePrq) ps_xml_p).
Definition Axml := Agreement (NewList Alice (Single Bob)) TheReport (PPS ps_xml).
\end{lstlisting}
%\end{minipage} 

\lstset{language=Coq, frame=single, caption={Fully Built Example
    Agreement in Coq}, label={lst:agreementincoq2}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Agreement (Alice, [Bob]) TheReport
         (PPS
            (PIPS
               (PrimitiveInclusivePolicySet (PreRequisite [TruePrq])
                  (Policy
                     [PrimitivePolicy
                        (PreRequisite
                           (Constraint (Principal [Alice]),
                            [Constraint (Count 2)])) id1 Print]))))

\end{lstlisting}
%\end{minipage} 

%%%% 125-semantics of ACCPL
\section{ACCPL Semantics}
We specify the semantics of \ac{ACCPL} as a translation function (the top level \syn{trans_agreement} function) from
an agreement together with an access request and an environment
containing all relevant facts, to decisions.  In this section, we
present the algorithms as high-level pseudocode.  The reader is
referred to the Coq code for their implementation, along with all the
auxiliary types and infrastructure which implement the semantics for
\ac{ACCPL}.


\subsection{Types of Decisions and their Implementation in Coq}\label{sec:answerandresulttypes}

As mentioned, in ACCPL, evaluating a request against a policy renders
a decision of ``granted'' (also called ``permitted''), ``denied'' or
``non-applicable.''  Including the ``non-applicable'' decision was
important for generality and for defining the semantics correctly.
Some policy based access-control languages use a two-valued decision,
indicating whether an access request is ``granted'' or ``denied.''  In
such languages, when a decision for a query does not evaluate to
``permit,'' the design choice taken is to return an explicit ``deny''
decision. However in this case ``deny'' stands for ``not permitted.''
It is desirable to handle the case when the policy truly doesn't
specify either a ``permit'' or a ``deny'' decision. In such cases
arbitrarily returning the decision ``deny'' makes it difficult to
compose policies.  To handle such cases, an explicit decision of ``non
applicable'' is desirable.  Alternatively, some languages may decide
to only support ``permit'' decisions. In such languages, the lack of a
``permit'' decision for a query signifies a default ``deny'' decision,
and thus ``deny'' decisions are not explicit. Although the policies of
these languages may be more readable than those with more explicit
decisions, they result in ambiguity on whether a ``deny'' decision was
really intended or not. Finally, some languages define an explicit
decision of ``error'' for cases such as when both ``permit'' and
``deny'' decisions are reached for the same query. An explicit
``error'' decision is preferable to undefined behaviour because it can
lead to improvements to policies and/or how the queries are
built~\cite{Tschantz}. The Coq encoding of our three-valued decision
set in \ac{ACCPL} is composed of the constants \syn{Permitted},
\syn{NotPermitted} and \syn{Unregulated} (used here to denote
``non-applicable'').

\subsection{Translations}\label{sec:translationfuncs}

Intuitively a query or request asks the following question given an agreement: ``May subject \syn{s} perform an action \syn{ac} to asset \syn{a}?'' We represent a query by its components, namely the subject, action and asset that form the query question: \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query} in Coq. 

 
Below, we present the high-level pseudocode of the main translation algorithm (implemented in the translation functions starting with \syn{trans_agreement}).
%
Listing~\ref{inclusivePS} for inclusive policy sets shows how a positive answer to a query in the form of a \syn{Permitted} decision is reached. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown. Listing~\ref{exclusivePS} for exclusive policy sets shows how a negative answer to a query in the form of a \syn{NotPermitted} decision is reached. This listing also shows that a positive decision of \syn{Permitted} is reached in exactly the same way as the case for inclusive policy sets. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown.

\lstset{language=pseudo, frame=single, caption={Access Decision Pseudocode: Inclusive Policy Sets}, label={inclusivePS}}
\begin{lstlisting}
    IF ($asset\_from\_query = asset\_from\_agreement$)
      IF ($subject\_from\_query$ is IN $prin\_u$)
        IF (The $preRequisite$ from the policy set HOLDS)
          IF (The $preRequisite$ from the policy HOLDS)
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is Permitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF            
          ELSE
             $result$ = Unregulated
          END_IF
        ELSE
          $result$ = Unregulated
        END_IF
      ELSE
           $result$ = Unregulated
      END_IF
    ELSE
      $result$ = Unregulated
    END_IF
\end{lstlisting}

\lstset{language=pseudo, frame=single, caption={Access Decision Pseudocode: Exclusive Policy Sets}, label={exclusivePS}}
\begin{lstlisting}
    IF ($asset\_from\_query = asset\_from\_agreement$)
      IF ($subject\_from\_query$ is IN $prin\_u$)
        IF (The $preRequisite$ from the policy set HOLDS)
          IF (The $preRequisite$ from the policy HOLDS)
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is Permitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF            
          ELSE
             $result$ = Unregulated
          END_IF
        ELSE
          $result$ = Unregulated
        END_IF
      ELSE
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is NotPermitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF
      END_IF
    ELSE
      $result$ = Unregulated
    END_IF
\end{lstlisting}

%%%%% 132-results chapter

\section{Correctness of ACCPL}\label{sec:maintheorems}

In this section, we present the theorems expressing the most important
properties we have proved about ACCPL.  For all supporting lemmas and
for all proofs, the reader is referred to the accompanying Coq code.

\subsection{Correctness of Translation}\label{sec:correct}

The \syn{trans_agreement_dec} theorem in Listing~\ref{lst:agreementdecidablecoq} is the declaration of the main correctness result for \ac{ACCPL}. Together with proofs for other theorems and lemmas, we have ``certified'' \ac{ACCPL} correct by proving this theorem. The list that \syn{trans_agreement} returns will contain results one per each primitive policy found in the agreement. Specifically the predicate \syn{isResultInQueryResult} checks for the existence of a particular result in the given list of results (definition of \syn{result} and \syn{answer} appears at the end of the listing). The theorem states that for all environments, agreements and queries (encoded in \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query}), the list that \syn{trans_agreement} produces contains either a \syn{Permitted} or a \syn{NotPermitted} result or the list will contain neither \syn{Permitted} nor \syn{NotPermitted} results.

\lstset{language=Coq, frame=single, caption={Agreement Translation's Correctness Property},label={lst:agreementdecidablecoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_dec:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),
   
 (isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) \/
 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) \/
 (~(isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\
  ~(isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))).

Inductive answer : Set := 
  | Permitted : answer 
  | Unregulated : answer  | NotPermitted : answer.
Inductive result : Set := 
 | Result : answer -> subject -> act -> asset -> result.    
\end{lstlisting}
%\end{minipage}


Note that by mentioning the agreement translation function directly in the statement of the theorem in Listing~\ref{lst:agreementdecidablecoq}, we tie the correctness property to how the translation functions work. To prove the theorem and with each successive subgoal during the interactive proof process, the definition of the translation function in scope gets unfolded and used so the translation functions have to be defined such that each subgoal is discharged and the proof is completed. 


As an example and also a visual aid to understanding how queries are
answered, see Listing~\ref{lst:permittedcoq}.
%
\lstset{language=Coq, frame=single, columns=flexible, caption={Access Request Resulting in Decision of \syn{Permitted}},label={lst:permittedcoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
isResultInQueryResult (Result Permitted Alice Print ebook) [ (Result Unregulated Alice Print ebook) ; (Result Unregulated Alice Print ebook) ; (Result Permitted Alice Print ebook) ]
\end{lstlisting}
%\end{minipage}
The \syn{isResultInQueryResult} predicate looks for a result with an
answer of \syn{Permitted} in the list that \syn{trans_agreement} has
produced, for an agreement for three primitive policies (since the set
contains three results). In words, we are asking whether Alice is
allowed to print the asset ebook, given a policy.
    
According to the theorem Listing~\ref{lst:agreementdecidablecoq} we have three mutually exclusive cases. The first case is when the set has a at least one \syn{Permitted} result; we answer the access query in this case with a result of \syn{Permitted}. (This would be the case in the Listing~\ref{lst:permittedcoq}.) The second case is when the set has at least one \syn{NotPermitted}; we answer the access query in this case with a result of \syn{NotPermitted}. In the case where all the results are \syn{Unregulated} we answer the access query with a result of \syn{Unregulated}. We show this case indirectly in the theorem in Listing~\ref{lst:agreementdecidablecoq} by stating the set does not contain a \syn{Permitted} result nor a \syn{NotPermitted} result. 

\subsection{Mutual Exclusivity of \syn{Permitted} and \syn{NotPermitted}}\label{sec:mutualexclusive}

The proof of the theorem in
Listing~\ref{lst:permandnotpermmutualexclusive} establishes that both
\syn{Permitted} and \syn{NotPermitted} results cannot exist in the
same set returned by \syn{trans_agreement}.  This result also
establishes the fact that in \ac{ACCPL} rendering conflicting
decisions is not possible given an agreement.

\lstset{language=Coq, frame=single, caption={\syn{Permitted} and \syn{NotPermitted}: Mutually Exclusive},label={lst:permandnotpermmutualexclusive}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_not_Perm_and_NotPerm_at_once:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),

 ~((isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\
 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))).
\end{lstlisting}
%\end{minipage}

The proof of the theorem in
Listing~\ref{lst:notpermandnotpermimpliesunregulated} shows that in
the case where neither a \syn{Permitted} nor a \syn{NotPermitted}
result exists in the set returned by \syn{trans_agreement}, there does
exist at least one \syn{Unregulated} result.

\lstset{language=Coq, frame=single, caption={Not (\syn{Permitted} and \syn{NotPermitted}) Implies \syn{Unregulated}},label={lst:notpermandnotpermimpliesunregulated}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_not_NotPerm_and_not_Perm_implies_Unregulated_dec:
  forall
    (e:environment)(ag:agreement)(action_from_query:act)
    (subject_from_query:subject)(asset_from_query:asset),

    (~(isResultInQueryResult 
      (Result Permitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\
    ~(isResultInQueryResult 
      (Result NotPermitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query))) ->
   (isResultInQueryResult 
      (Result Unregulated subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)).
\end{lstlisting}
%\end{minipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\blindtext\todo{Refine me}


%\begin{figure}
%Simple Figure
%\caption{Simple Figure}
%\label{fig:simple}
%\end{figure}
%
%\begin{table}
%\caption{Simple Table}
%
%\label{tab:simple}
%Simple Table
%\end{table}

%cref Demonstration: Cref at beginning of sentence, cref in all other cases.
%
%\Cref{fig:simple} shows a simple fact, although \cref{fig:simple} could also show something else.
%
%\Cref{tab:simple} shows a simple fact, although \cref{tab:simple} could also show something else.
%
%\Cref{sec:intro} shows a simple fact, although \cref{sec:intro} could also show something else.
%
%Brackets work as designed:
%<test>
%
%The symbol for powerset is now correct: $\powerset$ and not a Weierstrass p ($\wp$).
%
%\begin{inparaenum}
%\item All these items...
%\item ...appear in one line
%\item This is enabled by the paralist package.
%\end{inparaenum}
%
%``something in quotes'' using plain tex or use \enquote{the enquote command}.

\section{Conclusion}
We have presented the design and implementation of \ac{ACCPL} as a small and certifiably correct policy language. \ac{ACCPL} is a \ac{pbac} system that can be used to express general access-control rules and policies. In addition we have defined formal semantics for \ac{ACCPL} where we have discovered and added all possible cases when answering a query on whether to allow or deny an action to be performed on an asset. We have subsequently used the Coq Proof Assistant to state theorems about the expected behaviour of \ac{ACCPL} when evaluating a request with respect to a given policy, to develop proofs for those theorems and to machine-check the proofs ensuring correctness guarantees are provided. We have in particular stated, developed and proved correctness results for the semantics of \ac{ACCPL}. 

Additionally, we have described why certain design choices were made and how they contributed to the ease of reasoning for \ac{ACCPL}. Admittedly some expressive power present in other access-control policy languages was omitted from \ac{ACCPL} in order to achieve the reported correctness proofs. For example, in \ac{ACCPL} we only support base policy sets (policy sets that are not composed of other policy sets) i.e., no combining of base policy sets using conjunctions or other combining operators are supported. This is~\cite{BahPhd}.

\subsection{Related Work}
We review here related work and approaches
to defining semantics for \ac{pbac} based languages.
 
%\subsection{Lithium}
Halpern and Weissman~\cite{Halpern2008} use \ac{fol} to represent and reason about policies; policies describe the conditions under which a request to perform an action, such as reading a file, is granted or denied. They restrict \ac{fol} to get tractability for answering the query of whether a request to access a resource may be granted or denied, given a policy, and argue that despite the tractability results their language is still expressive. The authors focus on satisfying three requirements in the design of their language Lithium: expressive enough, tractable enough and usable by non-experts.

Holzer, et al~\cite{Holzer} give a semantics for \ac{odrl} that models the actions that are allowed according to a contract or an agreement. This model is presented in terms of automata. Each trace through the automaton represents a valid sequence of actions for each participant. The states of the automaton encode the state of the license at each point in time, meaning, which actions are allowed at what point considering the actions that have taken place in the past. 

%\subsection{Operational Semantics}
%Sheppard and Safavi-Naini~\cite{SheppardS09} propose an operational model for both formalizing and enforcing digital rights using a \emph{right expression compiler}. They use their model to develop operational semantics for \ac{oma}, from which an interpreter could be derived. 

%\subsection{Conflict Detection Algorithms}
Capretta, et al~\cite{CaprettaSFM07} present a conflict detection algorithm for the Cisco firewall specification~\cite{ciscofirewall} and formalize a correctness proof for it in the Coq proof assistant. The authors present their algorithm in Coq's functional programming language along with access rules and requests which are also encoded in Coq. The authors also prove in~\cite{CaprettaSFM07} that their algorithm finds all conflicts and only the correct conflicts in a set of rules. The algorithm is therefore verified formally to be both sound and complete.

Extending the above work, St-Martin and Felty~\cite{felty16} represent
policies for a fragment of \ac{xacml} 3.0 in the Coq proof assistant,
propose an algorithm for detecting all conflicts in \ac{xacml}
policies, and prove it correct. Their \ac{xacml} subset includes some
complex conditions such as time constraints. The policy language and
thus the conflict detection algorithm for XACML is much more complex
than the one for Cisco firewalls, and resulted in having to consider
many cases including many subtle corner cases.

\subsection{Future Work}


Our results subsume the above results on conflict detection in the
sense that for \ac{ACCPL}, we have formally proven that conflicts are
not possible.  This is an important aspect of our small certified core
language, but as this core is extended to cover more of the expressive
power of existing policy languages, this property will likely no
longer hold.  By starting with a conflict-free core, our goal is to
keep conflict detection as simple as possible as we add more features.

Tschantz and Krishnamurthi's~\cite{Tschantz} present a set of ``reasonability properties'' to analyze the behaviour of policies in light of additional and/or explicit environmental facts and policy growth and decomposition. We conjecture that \ac{ACCPL} supports these properties: it is deterministic, total, safe, and it has independent composition property and supports a monotonic policy combinator. However, we have not yet certified (using formal proofs) that \ac{ACCPL} has these properties, as we claim. We defer proving these properties for \ac{ACCPL} as future work. 

Another direction for future work is to explore different ways \ac{ACCPL} could be made more expressive. For example, we can add various policy combinators and their semantics to \ac{ACCPL} using the translation function framework. The translation function framework we have developed for \ac{ACCPL} is meant to keep the delicate balance between addition of expressiveness while maintaining provability of established results.

Another design goal for \ac{ACCPL} was to make it a target language for deploying policies written in other languages. We could capture, implement and study the semantics of these other policy-based access-control systems using the \ac{ACCPL} translation function framework and ultimately certify the semantics of those languages with respect to their specifications the same way \ac{ACCPL} has been certified correct. For example, we can take another \ac{pbac} system such as \ac{xrml} and \ac{odrl}, implement them in Coq as additional or (modifications of) existing \ac{ACCPL} constructs, analyze and reason about them, etc. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{splncs03}
\bibliography{accpl-sbmf2016}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
