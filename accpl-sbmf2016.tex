%"runningheads" enables:
%  - page number on page 2 onwards
%  - title/authors on even/odd pages
%This is good for other readers to enable proper archiving among other papers and pointing to content.
%Even if the title page states the title, when printed and stored in a folder, when blindly opening the folder, one could hit not the title page, but an arbitrary page. Therefore, it is good to have title printed on the pages, too.
\documentclass[runningheads,a4paper]{llncs}

%Even though `american`, `english` and `USenglish` are synonyms for babel package (according to https://tex.stackexchange.com/questions/12775/babel-english-american-usenglish), the llncs document class is prepared to avoid the overriding of certain names (such as "Abstract." -> "Abstract" or "Fig." -> "Figure") when using `english`, but not when using the other 2.
\usepackage[english]{babel}


%better font, similar to the default springer font
%cfr-lm is preferred over lmodern. Reasoning at http://tex.stackexchange.com/a/247543/9075
\usepackage[%
rm={oldstyle=false,proportional=true},%
sf={oldstyle=false,proportional=true},%
tt={oldstyle=false,proportional=true,variable=true},%
qt=false%
]{cfr-lm}
%
%if more space is needed, exchange cfr-lm by mathptmx
%\usepackage{mathptmx}

\usepackage{graphicx}

%extended enumerate, such as \begin{compactenum}
\usepackage{paralist}

%put figures inside a text
%\usepackage{picins}
%use
%\piccaptioninside
%\piccaption{...}
%\parpic[r]{\includegraphics ...}
%Text...

%Sorts the citations in the brackets
%\usepackage{cite}

\usepackage[T1]{fontenc}

%for demonstration purposes only
\usepackage[math]{blindtext}

%for easy quotations: \enquote{text}
\usepackage{csquotes}

%enable margin kerning
\usepackage{microtype}

%tweak \url{...}
\usepackage{url}
\usepackage[section]{algorithm}
\usepackage{algorithmic}
\usepackage{fancybox}
%\usepackage[]{algorithm2e}
%\usepackage{algpseudocode}
%nicer // - solution by http://tex.stackexchange.com/a/98470/9075
\makeatletter
\def\Url@twoslashes{\mathchar`\/\@ifnextchar/{\kern-.2em}{}}
\g@addto@macro\UrlSpecials{\do\/{\Url@twoslashes}}
\makeatother
\urlstyle{same}
%improve wrapping of URLs - hint by http://tex.stackexchange.com/a/10419/9075
\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother

%diagonal lines in a table - http://tex.stackexchange.com/questions/17745/diagonal-lines-in-table-cell
%slashbox is not available in texlive (due to licensing) and also gives bad results. This, we use diagbox
%\usepackage{diagbox}

%required for pdfcomment later
\usepackage{xcolor}

% new packages BEFORE hyperref
% See also http://tex.stackexchange.com/questions/1863/which-packages-should-be-loaded-after-hyperref-instead-of-before

%enable hyperref without colors and without bookmarks
\usepackage[
%pdfauthor={},
%pdfsubject={},
%pdftitle={},
%pdfkeywords={},
bookmarks=false,
breaklinks=true,
colorlinks=true,
linkcolor=black,
citecolor=black,
urlcolor=black,
%pdfstartpage=19,
pdfpagelayout=SinglePage,
pdfstartview=Fit
]{hyperref}
%enables correct jumping to figures when referencing
\usepackage[all]{hypcap}

%enable nice comments
\usepackage{pdfcomment}
\newcommand{\commentontext}[2]{\colorbox{yellow!60}{#1}\pdfcomment[color={0.234 0.867 0.211},hoffset=-6pt,voffset=10pt,opacity=0.5]{#2}}
\newcommand{\commentatside}[1]{\pdfcomment[color={0.045 0.278 0.643},icon=Note]{#1}}

%compatibality with TODO package
\newcommand{\todo}[1]{\commentatside{#1}}

%enable \cref{...} and \Cref{...} instead of \ref: Type of reference included in the link
\usepackage[capitalise,nameinlink]{cleveref}
%Nice formats for \cref
\crefname{section}{Sect.}{Sect.}
\Crefname{section}{Section}{Sections}

\usepackage{xspace}
%\newcommand{\eg}{e.\,g.\xspace}
%\newcommand{\ie}{i.\,e.\xspace}
\newcommand{\eg}{e.\,g.,\ }
\newcommand{\ie}{i.\,e.,\ }

\newcommand{\syn}{\texttt}

%%%%%% Languages
\usepackage{listings,lstautogobble}
\usepackage{syntax}
%\usepackage{lstcoq}
\usepackage{url}




\newcommand{\notimplies}{%
  \mathrel{{\ooalign{\hidewidth$\not\phantom{=}$\hidewidth\cr$\implies$}}}}

\newcommand{\algCaption}[1]{
    \caption{#1}
    \addcontentsline{lol}{lstlisting}{\protect\numberline{\thealgorithm}#1}
    \addtocounter{lstlisting}{1}}
\AtBeginEnvironment{lstlisting}{\addtocounter{algorithm}{1}}



\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily,
  frame=single,
  breaklines=true,
  morestring=[s]{"}{"},
  morecomment=[s]{?}{?},
  morecomment=[s]{!--}{--},
  commentstyle=\color{black},
  moredelim=[s][\color{black}]{>}{<},
  moredelim=[s][\color{black}]{\ }{=},
  stringstyle=\color{black},
  identifierstyle=\color{black},
  autogobble=true
}
\lstdefinelanguage{pseudo}
{
  morekeywords={
    IF, THEN, ELSE, END_IF, HOLDS, Permitted, NotPermitted, Unregulated, IN
  }
}
\lstdefinelanguage{Pucella2006}
{
  morekeywords={
    agreement, prin, asset, with, prePay, and, display, print, count
  }
}
\lstdefinelanguage{selinux}
{
  morekeywords={
    type, types, attrib, role, allow, user, constrain, avkind, 
	sourcetype, targettype, object-class, perm, allow, auditallow, dontaudit, neverallow,
	constrain, classes, perms, sourcetype, sourcerole, sourceuser, targettype, targetrole, targetuser
  }
}

\lstdefinelanguage{AST}
{
  basicstyle=\ttfamily,
  breaklines=true,
  morekeywords=[1]{
    prin, asset, subject, act, 
    policySet, primPolicySet, primExclusivePolicySet, primExclusivePolicySet, primInclusivePolicySet, primPolicy, 
    policy, policyId, primPrerequisite, prerequisite, constraint, agreement
  },
  tabsize=1,
}

\newtheorem{innercustomthm}{Theorem}
\newenvironment{customthm}[1]
  {\renewcommand\theinnercustomthm{#1}\innercustomthm}
  {\endinnercustomthm}


%%%%%% Languages

%introduce \powerset - hint by http://matheplanet.com/matheplanet/nuke/html/viewtopic.php?topic=136492&post_id=997377
\DeclareFontFamily{U}{MnSymbolC}{}
\DeclareSymbolFont{MnSyC}{U}{MnSymbolC}{m}{n}
\DeclareFontShape{U}{MnSymbolC}{m}{n}{
    <-6>  MnSymbolC5
   <6-7>  MnSymbolC6
   <7-8>  MnSymbolC7
   <8-9>  MnSymbolC8
   <9-10> MnSymbolC9
  <10-12> MnSymbolC10
  <12->   MnSymbolC12%
}{}
\DeclareMathSymbol{\powerset}{\mathord}{MnSyC}{180}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage{acro}

\input{list-of-acronyms}

\begin{document}

%Works on MiKTeX only
%hint by http://goemonx.blogspot.de/2012/01/pdflatex-ligaturen-und-copynpaste.html
%also http://tex.stackexchange.com/questions/4397/make-ligatures-in-linux-libertine-copyable-and-searchable
%This allows a copy'n'paste of the text from the paper
\input glyphtounicode.tex
\pdfgentounicode=1

\title{A Certified Core Policy Language}
%If Title is too long, use \titlerunning
%\titlerunning{Short Title}

%Single insitute
\author{Bahman Sistany \and Amy Felty}
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}
\institute{School of Electrical Engineering and Computer Science, University of Ottawa, Canada}

%Multiple insitutes
%Currently disabled
%
\iffalse
%Multiple institutes are typeset as follows:
\author{Firstname Lastname\inst{1} \and Firstname Lastname\inst{2} }
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}

\institute{
Insitute 1\\
\email{...}\and
Insitute 2\\
\email{...}
}
\fi
			
\maketitle

\begin{abstract}
We present the design and implementation of a Certified Core Policy Language (ACCPL) that can be used to express access-control policies. We define formal semantics for ACCPL where we discover and enumerate all possible cases when answering an access query. We use the Coq Proof Assistant to state theorems about the semantics of ACCPL, to develop proofs for those theorems and to machine-check the proofs ensuring correctness guarantees are provided. The main design goal for ACCPL is the ability to reason about the policies written in ACCPL with respect to specific questions. In addition ACCPL is designed to be extendable so that extensions to expressive power may be explored with respect to the established reasonability properties.  To this end, ACCPL is small (the syntax and the semantics of ACCPL only take a few pages to describe), although we believe ACCPL supports the core features of access-control policy languages.
\end{abstract}

\keywords{program correctness, formal verification, access control,
policy analysis, Coq, XACML, DRM, ODRL, SELinux}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:intro}
We describe the design of a \ac{ACCPL} and its implementation in the Coq Proof Assistant. Using Coq to implement \ac{ACCPL} was an important factor in its design, allowing us to address the trade-off between expressive power and ease of formal proof of correctness. 
The semantics of \ac{ACCPL} are specified by translation from policy statements together with an access request and an environment containing all the relevant facts, to decisions. We present results showing the translation functions behave correctly with respect to the decision question that asks whether a request to access a resource may be granted or denied, given a policy. The translation functions also cover the case where a given policy does not apply to a request in which case a decision of non-applicable is rendered. Our results show that for each access request, the translation algorithm terminates on all input policies with a decision of granted, denied or non-applicable. Proving that the translation algorithm terminates on all input policies (given an access request) with a decision of granted, denied or non-applicable, is the specific goal based on which the semantics were defined. We further capture this property as a specification (expressed as an inductive predicate in Coq) and show how the translation algorithm meets this specification for a given policy. 

To motivate the design of \ac{ACCPL} an access-control policy language, let us review the definition of ``access-control'': Authorization refers to the process of rendering a decision to allow access to a resource or asset of interest. By the same token all unauthorized access requests to resources must be controlled and ultimately denied, hence the term ``access-control''. 

Although various access-control models exist, to harmonize access control in large environments with many subjects and objects and disparate attributes, \ac{pbac} model has been proposed. \ac{pbac} allows for a more uniform access-control model across the system. There is also a need for large organizations to put in place mechanisms such that access-control rules can be easily audited. This calls for a data-driven approach to access-control where the data, in this case the access-control rules, are available to read and analyze. 

Because of the cited advantages of \ac{pbac} and its generality and wide spread use, \ac{pbac} is the model \ac{ACCPL} implements.

\subsection{A Core Policy Language for PBAC Systems} 

Does there already exist a suitable policy language that can be used for expressing general access-control expressions? How about \ac{xacml}~\cite{xacml3pdf}, \ac{odrl}~\cite{odrloneone} or \ac{xrml}~\cite{Wang}? 

Currently the most popular \ac{rel}s are \ac{xrml}, and \ac{odrl}. Both of these languages are XML based and are considered declarative languages. \ac{xrml} has been selected by the the Moving Picture Experts Group, MPEG, to be the \ac{rel} for \emph{MPEG-21} which is an ISO standard for multimedia applications. \ac{odrl} is also a standards-based \ac{rel} which has been accepted as part of the W3C community with the mandate of standardizing how rights and policies, related to the usage of digital content on the Open Web Platform, \emph{OWP}~\cite{openwebplatform}, are expressed. \ac{odrl} 2.0 supports expression of rights and also privacy rules for social media while \ac{odrl} 1.0 was only dealing with the mobile ecosystem -- \ac{odrl} 1.0 was adopted by the Open Mobile Alliance, \emph{OMA} in 2000.

\ac{rel}s, or more precisely \ac{drel}s when dealing with digital assets deal with the ``rights definition'' aspect of the \ac{drm} ecosystem. A \ac{drel}, allows the expression and definition of digital asset usage rights such that other areas of the \ac{drm} ecosystem, namely the enforcement mechanism and the usage tracking components can function correctly.

\ac{drm} refers to the digital management of rights associated with the access or usage of digital assets. There are various aspects of rights management however. According to the authors of the white paper ``A digital rights management ecosystem model for the education community''~\cite{collier} digital rights management systems cover the following four areas: 

\begin{enumerate}
  \item Defining rights 
  \item Distributing/Acquiring rights 
  \item Enforcing rights 
  \item Tracking usage
\end{enumerate}

\ac{xacml} is a high-level and platform independent access control system that is also XML based. \ac{xacml} is an OASIS standard which defines a language for the definition of policies and access requests, and a workflow to achieve policy enforcement~\cite{DBLP:conf/essos/MasiPT12}. According to Masi et al~\cite{DBLP:conf/essos/MasiPT12} designing XACML access control policies is difficult and error prone. Furthermore \ac{xacml} comes without a formal semantics as do both \ac{xrml} and \ac{odrl}. The \ac{xacml} standard is written in prose and contains quite a number of loose points that may give rise to different interpretations and lead to different implementation choices~\cite{DBLP:conf/essos/MasiPT12}.

\ac{xacml}, \ac{odrl} and \ac{xrml} are all \ac{pbac} based languages where \ac{odrl} and \ac{xrml} differ from \ac{xacml} by their focus on digital assets protection and in general \ac{drm}, hence the term \ac{rel}. All three are full-blown and custom languages that have one thing in common; they suffer from a lack of formal semantics. Additionally all of these languages cover much more than policy expressions leading to access decisions; they also address enforcement of policies (\ac{odrl} and \ac{xrml} specifically and \ac{drm} in general distinguish themselves from general access-control languages by additionally addressing enforcement of policies beyond where the policies were generated). A third reason that made these custom languages unsuitable as a core policy language was the fact that they are limited in terms of what can be built on top of them; for example expressing hierarchical role-based access-control  in \ac{xacml} requires a fairly complex encoding~\cite{Tschantz}.

Rights expressions in \ac{drel}s and specifically \ac{odrl} are used to arbitrate access to assets under conditions. The main construct in \ac{odrl} is the ``agreement'' which specifies users, asset(s) and policies whereby controls on users' access to the assets are described. This is very similar to how access control conditions are expressed in access control policy languages such as \ac{xacml}~\cite{xacml} and \ac{selinux}~\cite{selinux}. In fact several authors have worked on interoperability between \ac{rel}s and access control policy languages, specifically between \ac{odrl} and \ac{xacml}~\cite{prados2005interoperability,maronas2009architecture} and also on translation from high level policies of \ac{xacml} to low-level and fine grained policies of \ac{selinux}~\cite{alam2008usage}. 

A policy language based on logic and formal semantics but one that was small and extendible was needed. We use Pucella and Weissman's subset of \ac{odrl}~\cite{pucella2006} as the startinf point for \ac{ACCPL} and in doing so treat digital rights as our main access-control application without loss of generality with respect to other applications, with the final goal of performing formal verification on policies written in \ac{ACCPL}.



%----------------------------------------------------------------------
\subsection{Formal Semantics for PBAC Languages}
%----------------------------------------------------------------------


Formal methods help ensure that a system behaves correctly with respect to a specification of its desired behaviour~\cite{TAPL}. This specification of the desired behaviour is what's referred to as \emph{semantics} of the system. Using formal methods requires defining precise and formal semantics, without which analysis and reasoning about properties of the system in question would become impossible. For example, an issue with the current batch of \ac{rel}s are due to their semantics being expressed in a natural language (e.g. English) which by necessity results in ambiguous and open to interpretation behaviour. 

To formalize the semantics of \ac{pbac} languages several approaches have been attempted by various authors. Most are logic based~\cite{Halpern2008,pucella2006} while others are based on finite-automata~\cite{Holzer}, operational semantics based interpreters~\cite{Safavi-naini} and web ontology (from the Knowledge Representation Field)~\cite{Kasten2010MTS}. 


%\subsection{Logic Based Semantics}
%
%
%Formal logic can represent the statements and facts we express in a natural language like English. Propositional logic is expressive enough to express simple facts as propositions and uses connectives to allow for the negation, conjunction and disjunction of the facts. In addition simple facts can be expressed conditionally using the implication connective. Propositional logic however is not expressive enough to express policies of the kind used in languages like \ac{odrl} and \ac{xrml}. For example, a simple policy expressed in English like ``All who pay 5 dollars can watch the movie Toy Story'' cannot be expressed in propositional logic because the concept of quantifiers doesn't exist in propositional logic. 
%
%A richer logic such as ``First Order Logic'' (\emph{FOL}), is more suitable and has the expressive power to represent policies written in English. Moreover, FOL can be used to capture the meaning of policies in an unambiguous way.
%
%Halpern and Weissman~\cite{Halpern2008} propose a fragment of FOL to represent and reason about policies. The fragment of FOL they arrive at is called \emph{Lithium} which is decidable and allows for efficiently answering interesting queries. Lithium restricts policies to be written, in part based on the concept of ``bipolarity'' which disallows by construction policies that both permit and deny an action on an object. Pucella and Weissman~\cite{pucella2006} specify a predicate logic based language that represents a subset of ODRL.


\subsection{Specific Problem}

Policy languages and the agreements written in those languages are meant to implement specific goals such as limiting access to specific assets. The tension in designing a policy language is usually between how to make the language expressive enough, such that the design goals for the policy language may be expressed, and how to make the policies verifiable with respect to the stated goals.

As stated earlier, an important part of fulfilling the verifiability goal is to have formal semantics defined for policy languages. For \ac{odrl}, authors of~\cite{pucella2006} define a formal semantics based on which they declare and prove a number of important theorems (their main focus is on stating and proving algorithm complexity results). However as with many paper-proofs, the language used to do the proofs while mathematical in nature, uses many intuitive justifications to show the proofs. As such these proofs are difficult to verify or to ``derive''. Furthermore the proofs can not be used directly to render a decision on a sample policy (e.g. whether to allow or deny access to an asset). Of course one may (carefully) construct a program based on these proofs for practical purposes but certifying such programs correct presents additional verification challenges, even assuming the original proofs were in fact correct.

\subsection{Contributions}\label{sec:contribs}

We designed a policy based access-control language called \ac{ACCPL} based on \ac{odrl} and starting with definitions in~\cite{pucella2006}. The \ac{ACCPL} framework has been encoded in \emph{Coq}~\cite{BC04} which is both a programming language and a proof-assistant. We have specified and proved \ac{ACCPL} correct with respect to properties of interest (see section~\ref{sec:maintheorems}) in Coq which will allow us to extract programs from the proofs; the executable programs can be used on specific policies and a query, to render a specific decision such as ``a permission has been granted''. 

We originally started with a specific subset of~\cite{pucella2006} so that we could concentrate on what we believed to be the essence or core of the language. Initially we intended to maintain the central semantic definitions including ``Closed World Assumptions''~\cite{pucella2006} where the semantics only specify explicitly Permitted and NotPermitted answers however we discovered the semantics as stated by Pucella and Weissman~\cite{pucella2006} are not explicit and therefore the decision question that asks whether a request to access a resource may be granted or denied, may not be answered in all cases. We have therefore made major modifications to the semantics of Pucella and Weissman's language such that an answer to a request for access to a resource may be determined unambiguously and for all cases. 
    
Our results subsume an important sub-category, namely inconsistency or conflict-detection in policy expressions or rules. St-Martin and Felty~\cite{felty16} describe and implement in Coq a conflict detection algorithm for detecting conflicts in \ac{xacml} access control rules. \ac{xacml} is an expressive and at the same time complex policy language which makes conflict detection a difficult task. The authors of~\cite{felty16} then prove the conflict detection algorithm correct (or certified) by developing a formal proof in Coq. The proof is rather complex and involves a large number of cases, including many corner cases that were difficult to get right~\cite{felty16}. For \ac{ACCPL} we have formally proven that conflicts are not possible.

Given that \ac{ACCPL} is a core policy language with semantics that have been certified correct, we could use \ac{ACCPL} to implement various (more expressive) policy languages. In addition \ac{ACCPL} could be used as an intermediate language to reason about interoperability between those policy languages~\cite{prados2005interoperability,maronas2009architecture}. In this manner our language \ac{ACCPL} can be viewed as a extendable language, complete with defined and verified semantics, that can be used as the basis for implementing various policy languages with more expressive power (e.g. W3C's \ac{odrl} and \ac{selinux}). 

For access to the Coq source code for \ac{ACCPL}, please refer to \url{http://www.site.uottawa.ca/~afelty/accpl/}.

\section{ACCPL Abstract Syntax}
%% Coq Syntax chapter

We follow the style of~\cite{pucella2006} by using abstract syntax to express policy statements in \ac{ACCPL}. 

\subsection{Environmental Facts}\label{sec:odrl0}
To determine the outcome of policies, specified conditions in those policies are evaluated but to do so environmental facts are often needed. In the \ac{drm} realm with its focus on usage control, certain facts are typically tracked in the environment. The count of how many times an asset has been accessed, the amount a user has paid to access an asset and finally whether a user has made an attribution (e.g. mentioning the content owner by name) are examples of the kind of facts environments hold.

In \ac{ACCPL}, agreements and facts (i.e. environments) will refer to a count of how many times each policy should be used and has been used respectively, to justify an action. 

\subsection{Abstract Syntax for ACCPL} \label{sec:productionast}


\newcommand*{\Comment}[1]{\hfill\makebox[5.0cm][l]{#1}}%
\newcommand*{\CommentPP}[1]{\hfill\makebox[3.0cm][l]{#1}}%
% agreement
\lstset{mathescape, language=AST, escapechar=\&} 
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Abstract Syntax for ACCPL},label={lst:agreementast}]
<agreement> ::= 
     'agreement' 'for' <prin> 'about' <asset> 'with' <policySet> 
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
<asset> ::= TheReport | ebook | latestJingle | ...
<subject> ::= Alice | Bob | ...
<act> ::= Play | Print | Display | ...
<policySet> ::=  
  <primPolicySet> &\Comment{; primitive policy set}&
<primPolicySet> ::=  
   <primInclusivePolicySet> &\Comment{; primitive inclusive policy set}&
  |<primExclusivePolicySet> &\Comment{; primitive exclusive policy set}&
<primExclusivePolicySet> ::=  
  <prerequisite> $\mapsto$ <policy> &\Comment{; primitive exclusive policy set}&
<primInclusivePolicySet> ::=  
  <prerequisite> $\rightarrow$ <policy> &\Comment{; primitive inclusive policy set}&
<primPolicy> ::=  
  <prerequisite> $\Rightarrow_{<policyId>}$ <act> &\CommentPP{; primitive policy}&
<policy> ::=  
  'and'[ <primPolicy$_{1}$>, ..., 
      <primPolicy$_{m}$> ] &\CommentPP{; conjunction}&
 <policyId> ::= N 
<primPrerequisite> ::=  
    'True' &\Comment{; always true}&
  |  <constraint>	 &\Comment{; constraint}&
  |  'not' [ <constraint> ] &\Comment{; suspending constraint}&    
<prerequisite> ::=    
  |  'and'[ <primPrerequisite$_{1}$>, ..., 
    <primPrerequisite$_{m}$> ] &\Comment{; conjunction }&
<constraint> ::=  
    <prin> &\Comment{; principal}&
  |  'Count' [N] &\Comment{; number of executions}&
  |  <prin> ('Count' [N]) &\Comment{; number of executions by prin}&     
\end{lstlisting}
\end{minipage} 

The abstract syntax for \ac{ACCPL} is given in Listing~\ref{lst:agreementast}. The top level production is the \syn{<agreement>}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects called a principal or \syn{<prin>}, an \syn{<asset>} and a \syn{<policySet>}. Principals (\syn{<prin>}) are composed of \syn{<subject>}s which are specified based on the application e.g. \syn{Alice}, \syn{Bob}, etc. Assets and actions are also application specific such as \syn{TheReport} and \syn{ebook} for assets and \syn{Display} and \syn{Print} for actions. 

A policy set is a primitive policy set implying non-nested policy sets. Each primitive policy set specifies a \syn{<prerequisite>} and a \syn{<policy>}. Intuitively if the prerequisite ``holds'' the policy is taken into consideration. Otherwise the policy will not be looked at. Some primitive policy sets are specified as inclusive as opposed to others that are explicitly specified as exclusive. Primitive exclusive policy sets are exclusive to an agreement's users in that only those users may perform the actions specified in the policy set. The implication is that all other users who are not specified in the agreement's principal are forbidden from performing the specified actions, no matter whether the prerequisite holds or not. Not surprisingly we also define primitive inclusive policy sets that don't enforce any exclusivity to the agreement's users.

A primitive policy specifies an action to be performed on an asset, depending on whether the policy's prerequisite holds or not. If the prerequisite holds the agreement's user is permitted to perform the action on the agreement's asset; otherwise permission is denied. A unique identifier for each policy to help the translation (from agreements to formulas), called the policy identifier (\syn{<policyId>}) is included in our definition of the policy construct, however, as far as the proofs are concerned the policy identifier could be removed without a loss to the obtained results. A policy is made up of primitive policies. Primitive policies are grouped together using the conjunction combining operator.

In \ac{ACCPL} a \syn{<primPrerequisite>} is either True or it is a \syn{<constraint>}. The True prerequisite always holds. A constraint is an intrinsic part of a policy and cannot be influenced by agreement's users. A constraint can also be negative, specified by the keyword `not' in front of \syn{<constraint>}. A \syn{<prerequisite>} is a set of primitive prerequisites which are closed under conjunction operator specified by the keyword `and' in front of the list of the primitive prerequisites separated by commas.

Constraints are either of the principal kind, the count kind, or the count by principle kind. Principal constraints require matching to the users listed following the keyword \syn{<prin>}. For example, the constraint of ``the user being Alice'' is a constraint of type principal. A count constraint refers to the number of times the user of an agreement has invoked policies to justify her actions. If the count constraint is part of a policy then the count refers to that single policy. In the case that the count constraint is part of a policy set or if the policy is a conjunction, then the count refers to the set of policies specified in the policy set or in the policy conjunction as the case may be.


\section{Introduction to Coq}

Coq is known first and foremost as a proof-assistant. The underlying formal language that Coq uses is a much more expressive version of typed lambda calculus called \ac{cic} where proofs and programs can both be represented. For example, \ac{cic} adds polymorphism (terms depending on types), type operators (types depending on types) and dependent types (types depending on terms).

Specifications of programs in Coq may be expressed using the specification language \emph{Gallina}~\cite{gallinaref}. Coq is then used to develop proofs to show that a program's run-time behaviour satisfies its specification. Such programs are called \emph{certified} because they are formally verified and confirmed to conform to their specifications~\cite{BC04}.

\section{ACCPL Syntax in Coq}\label{sec:agreementConstructor}

\ac{ACCPL} productions were presented as high level abstract syntax in Section~\ref{sec:productionast}. We present the corresponding encodings in Coq in Listing~\ref{lst:agreementcoq}. Note that the data type \syn{nonemptylist} represents a list data structure that has at least one element and data types \syn{asset}, \syn{subject}, \syn{act} and \syn{policyId} are simply defined as Coq's \syn{nat}.

\lstset{language=Coq}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={ACCPL: Coq Version of Agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.
Definition prin := nonemptylist subject.
Inductive policySet : Set :=
  | PPS : primPolicySet -> policySet.
Inductive primPolicySet : Set :=
  | PIPS : primInclusivePolicySet -> primPolicySet
  | PEPS : primExclusivePolicySet -> primPolicySet.
Inductive primInclusivePolicySet : Set :=
  | PrimitiveInclusivePolicySet : preRequisite -> policy -> primInclusivePolicySet.
Inductive primExclusivePolicySet : Set :=
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> primExclusivePolicySet.
Inductive policy : Set :=
  | Policy : nonemptylist primPolicy -> policy.
Inductive primPolicy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> primPolicy.  
Inductive primPreRequisite : Set :=
  | TruePrq : primPreRequisite
  | Constraint : constraint -> primPreRequisite
  | NotCons : constraint -> primPreRequisite.
Inductive preRequisite : Set :=
  | PreRequisite : nonemptylist primPreRequisite -> preRequisite.
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.  
\end{lstlisting}
\end{minipage}

We now show the statement expressing ``the asset TheReport may be printed a total of 2 times by Alice only'' in the abstract syntax notation in~\ref{lst:agreementinAST}, as encodings of \ac{ACCPL} constructs in Coq in~\ref{lst:agreementincoq} and finally as an \ac{ACCPL} construct in~\ref{lst:agreementincoq2}.

\lstset{language=Pucella2006}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={First Agreement for Alice and Bob}, label={lst:agreementinAST}, mathescape]
agreement
 for Alice and Bob
 about The Report
 with True -> and[Alice, count[2]] =>$_{id1}$ print.
\end{lstlisting}
\end{minipage}

\lstset{language=Coq, frame=single, caption={Expressing First Agreement for Alice and Bob in ACCPL}, label={lst:agreementincoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition ps_xml_p1prq1:primPreRequisite := 
  (Constraint (Principal (Single Alice))).
Definition ps_xml_p1prq2:primPreRequisite := 
  (Constraint (Count 2)).
Definition ps_xml_prq:preRequisite := 
  (PreRequisite (NewList ps_xml_p1prq1 (Single ps_xml_p1prq2))).
Definition ps_xml_p1:primPolicy := 
  (PrimitivePolicy ps_xml_prq id1 Print).
Definition ps_xml_p:policy := 
  (Policy (Single ps_xml_p1)).
Definition ps_xml:primPolicySet :=
  PIPS (PrimitiveInclusivePolicySet
    (makePreRequisite TruePrq) ps_xml_p).
Definition Axml := Agreement (NewList Alice (Single Bob)) TheReport (PPS ps_xml).
\end{lstlisting}
\end{minipage} 

\lstset{language=Coq, frame=single, caption={Fully Built First Agreement for Alice and Bob in ACCPL}, label={lst:agreementincoq2}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Agreement (Alice, [Bob]) TheReport
         (PPS
            (PIPS
               (PrimitiveInclusivePolicySet (PreRequisite [TruePrq])
                  (Policy
                     [PrimitivePolicy
                        (PreRequisite
                           (Constraint (Principal [Alice]),
                            [Constraint (Count 2)])) id1 Print]))))

\end{lstlisting}
\end{minipage} 

%%%% 125-semantics of ACCPL
\section{Semantics}
We specify the semantics of \ac{ACCPL} as a translation function from an agreement together with an access request and an environment containing all relevant facts, to decisions (more concretely to a set of \syn{result}s--see listing~\ref{lst:answercoq}). This is done based on whether there are proof terms for certain conditions and/or proof terms for the negation of those conditions. The translation functions plus the auxiliary types and infrastructure which implement the semantics for \ac{ACCPL} have been encoded in Coq.

Whether an agreement and the accompanying access request or query is translated into a decision indicating a permission is granted or denied depends on the agreement in question and the specifics of the request, but also on the number of times a policy has been used to justify an action. We encode this information in Coq as an inductive type representing the environment. An \syn{environment} is a conjunction of equalities of the form \syn{count(subject, policyId) = n} which are called ``count equalities''.

The \syn{sumbool} type is a boolean type defined in the Coq standard library; it captures the idea of program values that indicate which of two propositions is true~\cite{chlipalacpdt2011}. The \syn{sumbool} type is equipped with the justification of their value~\cite{Coq:manual} which help with proofs. Using a tactic like \syn{destruct}~\cite{Coq:manual} two subgoals are generated, one for each form of the \syn{sumbool} instance, however the justifications also show up as hypothesis helping with discharging of the subgoals. We have used the \syn{sumbool} type to declare and prove decision procedures that we have subsequently used in the translation functions implementing the semantics and also in the proofs.

\subsection{Types of Decisions and their Implementation in Coq}\label{sec:answerandresulttypes}

Policy based access-control languages typically use a two-valued decision set to indicate whether an access request is granted or denied. When a decision for a query is not granted, one design choice for a language is to return an explicit deny decision. However in this case deny stands for ``not permitted''. It is possible to have cases when the policy truly doesn't specify either a permit or a deny decision. In such cases arbitrarily returning the decision of deny makes it difficult to compose policies and in fact, an explicit decision of ``non applicable'' is warranted in such cases. Some languages may decide to only support permit decisions. In such languages lack of a permit decision for a query signifies a deny decision so deny decisions are not explicit. Although the policies of these languages may be more readable than those with more explicit decisions, they result in ambiguity on whether a deny decision was really intended or not. Finally some languages define an explicit decision of ``error'' for cases such as when both permit and deny decisions are reached for the same query. An explicit error decision is preferable to undefined behaviour because it can lead to improvements to policies and/or how the queries are built~\cite{Tschantz}. 

In \ac{ACCPL} we use a three-valued decision set: \syn{Permitted}, \syn{NotPermitted} and \syn{Unregulated} (used as synonymous with ``non-applicable''). A \syn{Permitted} answer signifies that the access request has been granted. The \syn{NotPermitted} answer is for when the access request is denied. And finally the \syn{Unregulated} answer is for all the times when neither \syn{Permitted} or \syn{NotPermitted} answers are applicable.

\subsection{Translations}\label{sec:translationfuncs}

Intuitively a query or request asks the following question given an agreement: ``May subject \syn{s} perform an action \syn{ac} to asset \syn{a}?''. We represent a query by its components, namely the subject, action and asset that form the query question: \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query}. While developing the proofs for the correctness of \ac{ACCPL} we realized we needed this query specific information deep in the translation functions to be able to render unambiguous decisions and ultimately make the proofs work. We therefore pass the query components to all the translation functions starting with the \syn{trans_agreement} function (see listing~\ref{lst:transagreement}). 

In the following we present the high-level description of how the main algorithm (encoded in the translation functions) works in two separate listings based on whether the policy set in question is inclusive or exclusive. 

The first listing (~\ref{inclusivePS}) for inclusive policy sets, shows how a positive answer to a query in the form of a \syn{Permitted} decision is reached. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown. The second listing (~\ref{exclusivePS}) for exclusive policy sets, shows how a negative answer to a query in the form of a \syn{NotPermitted} decision is reached. This listing also shows that a positive decision of \syn{Permitted} is reached in exactly the same way as the case for inclusive policy sets. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown.

\lstset{language=pseudo, frame=single, caption={Access Decision Pseudocode: Inclusive Policy Sets}, label={inclusivePS}}
\begin{lstlisting}
    IF ($asset\_from\_query = asset\_from\_agreement$)
      IF ($subject\_from\_query$ is IN $prin\_u$)
        IF (The $preRequisite$ from the policy set HOLDS)
          IF (The $preRequisite$ from the policy HOLDS)
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is Permitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF            
          ELSE
             $result$ = Unregulated
          END_IF
        ELSE
          $result$ = Unregulated
        END_IF
      ELSE
           $result$ = Unregulated
      END_IF
    ELSE
      $result$ = Unregulated
    END_IF
\end{lstlisting}

\lstset{language=pseudo, frame=single, caption={Access Decision Pseudocode: Exclusive Policy Sets}, label={exclusivePS}}
\begin{lstlisting}
    IF ($asset\_from\_query = asset\_from\_agreement$)
      IF ($subject\_from\_query$ is IN $prin\_u$)
        IF (The $preRequisite$ from the policy set HOLDS)
          IF (The $preRequisite$ from the policy HOLDS)
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is Permitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF            
          ELSE
             $result$ = Unregulated
          END_IF
        ELSE
          $result$ = Unregulated
        END_IF
      ELSE
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is NotPermitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF
      END_IF
    ELSE
      $result$ = Unregulated
    END_IF

\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\blindtext\todo{Refine me}


%\begin{figure}
%Simple Figure
%\caption{Simple Figure}
%\label{fig:simple}
%\end{figure}
%
%\begin{table}
%\caption{Simple Table}
%
%\label{tab:simple}
%Simple Table
%\end{table}

%cref Demonstration: Cref at beginning of sentence, cref in all other cases.
%
%\Cref{fig:simple} shows a simple fact, although \cref{fig:simple} could also show something else.
%
%\Cref{tab:simple} shows a simple fact, although \cref{tab:simple} could also show something else.
%
%\Cref{sec:intro} shows a simple fact, although \cref{sec:intro} could also show something else.
%
%Brackets work as designed:
%<test>
%
%The symbol for powerset is now correct: $\powerset$ and not a Weierstrass p ($\wp$).
%
%\begin{inparaenum}
%\item All these items...
%\item ...appear in one line
%\item This is enabled by the paralist package.
%\end{inparaenum}
%
%``something in quotes'' using plain tex or use \enquote{the enquote command}.

\section{Conclusion and Outlook}

...

In the bibliography, use \texttt{\textbackslash textsuperscript} for ``st'', ``nd'', ...:
E.g., \enquote{The 2\textsuperscript{nd} conference on examples}.
When you use \href{http://www.jabref.org}{JabRef}, you can use the clean up command to achieve that.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{splncs03}
\bibliography{accpl-sbmf2016}

All links were last followed on October 5, 2014.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
