%"runningheads" enables:
%  - page number on page 2 onwards
%  - title/authors on even/odd pages
%This is good for other readers to enable proper archiving among other papers and pointing to content.
%Even if the title page states the title, when printed and stored in a folder, when blindly opening the folder, one could hit not the title page, but an arbitrary page. Therefore, it is good to have title printed on the pages, too.
\documentclass[runningheads,a4paper]{llncs}

%Even though `american`, `english` and `USenglish` are synonyms for babel package (according to https://tex.stackexchange.com/questions/12775/babel-english-american-usenglish), the llncs document class is prepared to avoid the overriding of certain names (such as "Abstract." -> "Abstract" or "Fig." -> "Figure") when using `english`, but not when using the other 2.
\usepackage[english]{babel}


%better font, similar to the default springer font
%cfr-lm is preferred over lmodern. Reasoning at http://tex.stackexchange.com/a/247543/9075
\usepackage[%
rm={oldstyle=false,proportional=true},%
sf={oldstyle=false,proportional=true},%
tt={oldstyle=false,proportional=true,variable=true},%
qt=false%
]{cfr-lm}
%
%if more space is needed, exchange cfr-lm by mathptmx
%\usepackage{mathptmx}

\usepackage{graphicx}

%extended enumerate, such as \begin{compactenum}
\usepackage{paralist}

%put figures inside a text
%\usepackage{picins}
%use
%\piccaptioninside
%\piccaption{...}
%\parpic[r]{\includegraphics ...}
%Text...

%Sorts the citations in the brackets
%\usepackage{cite}

\usepackage[T1]{fontenc}

%for demonstration purposes only
\usepackage[math]{blindtext}

%for easy quotations: \enquote{text}
\usepackage{csquotes}

%enable margin kerning
\usepackage{microtype}

%tweak \url{...}
\usepackage{url}
\usepackage[section]{algorithm}
\usepackage{algorithmic}
\usepackage{fancybox}
%\usepackage[]{algorithm2e}
%\usepackage{algpseudocode}
%nicer // - solution by http://tex.stackexchange.com/a/98470/9075
\makeatletter
\def\Url@twoslashes{\mathchar`\/\@ifnextchar/{\kern-.2em}{}}
\g@addto@macro\UrlSpecials{\do\/{\Url@twoslashes}}
\makeatother
\urlstyle{same}
%improve wrapping of URLs - hint by http://tex.stackexchange.com/a/10419/9075
\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother

%diagonal lines in a table - http://tex.stackexchange.com/questions/17745/diagonal-lines-in-table-cell
%slashbox is not available in texlive (due to licensing) and also gives bad results. This, we use diagbox
%\usepackage{diagbox}

%required for pdfcomment later
\usepackage{xcolor}

% new packages BEFORE hyperref
% See also http://tex.stackexchange.com/questions/1863/which-packages-should-be-loaded-after-hyperref-instead-of-before

%enable hyperref without colors and without bookmarks
\usepackage[
%pdfauthor={},
%pdfsubject={},
%pdftitle={},
%pdfkeywords={},
bookmarks=false,
breaklinks=true,
colorlinks=true,
linkcolor=black,
citecolor=black,
urlcolor=black,
%pdfstartpage=19,
pdfpagelayout=SinglePage,
pdfstartview=Fit
]{hyperref}
%enables correct jumping to figures when referencing
\usepackage[all]{hypcap}

%enable nice comments
\usepackage{pdfcomment}
\newcommand{\commentontext}[2]{\colorbox{yellow!60}{#1}\pdfcomment[color={0.234 0.867 0.211},hoffset=-6pt,voffset=10pt,opacity=0.5]{#2}}
\newcommand{\commentatside}[1]{\pdfcomment[color={0.045 0.278 0.643},icon=Note]{#1}}

%compatibality with TODO package
\newcommand{\todo}[1]{\commentatside{#1}}

%enable \cref{...} and \Cref{...} instead of \ref: Type of reference included in the link
\usepackage[capitalise,nameinlink]{cleveref}
%Nice formats for \cref
\crefname{section}{Sect.}{Sect.}
\Crefname{section}{Section}{Sections}

\usepackage{xspace}
%\newcommand{\eg}{e.\,g.\xspace}
%\newcommand{\ie}{i.\,e.\xspace}
\newcommand{\eg}{e.\,g.,\ }
\newcommand{\ie}{i.\,e.,\ }

\newcommand{\syn}{\texttt}

%%%%%% Languages
\usepackage{listings,lstautogobble}
\usepackage{syntax}
%\usepackage{lstcoq}
\usepackage{url}




\newcommand{\notimplies}{%
  \mathrel{{\ooalign{\hidewidth$\not\phantom{=}$\hidewidth\cr$\implies$}}}}

\newcommand{\algCaption}[1]{
    \caption{#1}
    \addcontentsline{lol}{lstlisting}{\protect\numberline{\thealgorithm}#1}
    \addtocounter{lstlisting}{1}}
\AtBeginEnvironment{lstlisting}{\addtocounter{algorithm}{1}}



\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily,
  frame=single,
  breaklines=true,
  morestring=[s]{"}{"},
  morecomment=[s]{?}{?},
  morecomment=[s]{!--}{--},
  commentstyle=\color{black},
  moredelim=[s][\color{black}]{>}{<},
  moredelim=[s][\color{black}]{\ }{=},
  stringstyle=\color{black},
  identifierstyle=\color{black},
  autogobble=true
}
\lstdefinelanguage{pseudo}
{
  morekeywords={
    IF, THEN, ELSE, END_IF, HOLDS, Permitted, NotPermitted, Unregulated, IN
  }
}
\lstdefinelanguage{Pucella2006}
{
  morekeywords={
    agreement, prin, asset, with, prePay, and, display, print, count
  }
}
\lstdefinelanguage{selinux}
{
  morekeywords={
    type, types, attrib, role, allow, user, constrain, avkind, 
	sourcetype, targettype, object-class, perm, allow, auditallow, dontaudit, neverallow,
	constrain, classes, perms, sourcetype, sourcerole, sourceuser, targettype, targetrole, targetuser
  }
}

\lstdefinelanguage{AST}
{
  basicstyle=\ttfamily,
  breaklines=true,
  morekeywords=[1]{
    prin, asset, subject, act, 
    policySet, primPolicySet, primExclusivePolicySet, primExclusivePolicySet, primInclusivePolicySet, primPolicy, 
    policy, policyId, primPrerequisite, prerequisite, constraint, agreement
  },
  tabsize=1,
}

\newtheorem{innercustomthm}{Theorem}
\newenvironment{customthm}[1]
  {\renewcommand\theinnercustomthm{#1}\innercustomthm}
  {\endinnercustomthm}


%%%%%% Languages

%introduce \powerset - hint by http://matheplanet.com/matheplanet/nuke/html/viewtopic.php?topic=136492&post_id=997377
\DeclareFontFamily{U}{MnSymbolC}{}
\DeclareSymbolFont{MnSyC}{U}{MnSymbolC}{m}{n}
\DeclareFontShape{U}{MnSymbolC}{m}{n}{
    <-6>  MnSymbolC5
   <6-7>  MnSymbolC6
   <7-8>  MnSymbolC7
   <8-9>  MnSymbolC8
   <9-10> MnSymbolC9
  <10-12> MnSymbolC10
  <12->   MnSymbolC12%
}{}
\DeclareMathSymbol{\powerset}{\mathord}{MnSyC}{180}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage{acro}

\input{list-of-acronyms}

%\usepackage{refcheck}

\begin{document}

%Works on MiKTeX only
%hint by http://goemonx.blogspot.de/2012/01/pdflatex-ligaturen-und-copynpaste.html
%also http://tex.stackexchange.com/questions/4397/make-ligatures-in-linux-libertine-copyable-and-searchable
%This allows a copy'n'paste of the text from the paper
\input glyphtounicode.tex
\pdfgentounicode=1

\title{A Certified Core Policy Language}
%If Title is too long, use \titlerunning
%\titlerunning{Short Title}

%Single insitute
\author{Bahman Sistany\inst{1,2} \and Amy Felty\inst{1}}
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}
\institute{School of Electrical Engineering and Computer Science\\
  University of Ottawa, Ottawa, Canada
\and
Irdeto Canada Corporation, Ottawa, Canada\\
  \email{bahman.sistany@irdeto.com}, \email{afelty@uottawa.ca}
}

%Multiple insitutes
%Currently disabled
%
\iffalse
%Multiple institutes are typeset as follows:
\author{Firstname Lastname\inst{1} \and Firstname Lastname\inst{2} }
%If there are too many authors, use \authorrunning
%\authorrunning{First Author et al.}

\institute{
Insitute 1\\
\email{...}\and
Insitute 2\\
\email{...}
}
\fi
			
\maketitle

\begin{abstract}
%We present the design and implementation of a Certified Core Policy Language (ACCPL) that can be used to express access-control policies. We define formal semantics for ACCPL where we discover and enumerate all possible cases when answering an access query. We use the Coq Proof Assistant to state theorems about the semantics of ACCPL, to develop proofs for those theorems and to machine-check the proofs ensuring correctness guarantees are provided. The main design goal for ACCPL is the ability to reason about the policies written in ACCPL with respect to specific questions. In addition ACCPL is designed to be extendable so that extensions to expressive power may be explored with respect to the established reasonability properties.  To this end, ACCPL is small (the syntax and the semantics of ACCPL only take a few pages to describe), although we believe ACCPL supports the core features of access-control policy languages.
We present the design and implementation of a Certified Core Policy
Language (ACCPL) that can be used to express access-control policies.
We define formal semantics for ACCPL and use the Coq Proof Assistant
to state theorems about this semantics, to develop proofs for those
theorems and to machine-check the proofs ensuring correctness
guarantees are provided. The main design goal for ACCPL is the ability
to reason about the policies written in ACCPL with respect to specific
questions. In addition ACCPL is designed to be extendable so that
extensions to expressive power may be explored with respect to the
established correctness properties.  To this end, ACCPL is small (the
syntax and the semantics of ACCPL only take a few pages to describe),
although we believe ACCPL supports the core features of access-control
policy languages.
\end{abstract}

\keywords{program correctness, formal verification, access control,
policy analysis, Coq, XACML, DRM, ODRL, SELinux}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:intro}
We describe the design of a \ac{ACCPL} 
% new phrase
for expressing access control policies
%
and its implementation in the
Coq Proof Assistant. Using Coq to implement \ac{ACCPL} was an
important factor in its design, allowing us to address the trade-off
between expressive power and ease of formal proof of correctness.
The semantics of \ac{ACCPL} are specified by translation from policy
statements together with an access request and an environment
containing all the relevant facts, to decisions. We present results
showing the translation functions behave correctly with respect to the
decision question that asks whether a request to access a resource may
be granted or denied, given a policy. The translation functions also
cover the case where a given policy does not apply to a request in
which case a decision of non-applicable is rendered. Our results show
that for each access request, the translation algorithm terminates on
all input policies with a decision of granted, denied or
non-applicable.
%Proving that the translation algorithm terminates on all input policies (given an access request) with a decision of granted, denied or non-applicable, is the specific goal based on which the semantics were defined.

%To motivate the design of \ac{ACCPL} an access-control policy
%language, let us review the definition of ``access-control'':
%Authorization refers to the process of rendering a decision to allow
%access to a resource or asset of interest. By the same token all
%unauthorized access requests to resources must be controlled and
%ultimately denied, hence the term ``access-control''.
To motivate the design of \ac{ACCPL}, let us review the definition of
``access-control'': Authorization refers to the process of rendering a
decision about whether to permit or deny access to a resource or asset
of interest, hence the term ``access-control.''

Although various access-control models exist, to harmonize access control in large environments with many subjects and objects and disparate attributes, the \ac{pbac}~\cite{nist} model has been proposed. \ac{pbac} allows for a uniform and central access-control model among the various organizational units. There is also a need for large organizations to put in place mechanisms so that access-control rules can be easily audited. This calls for a data-driven approach to access-control where the data, in this case the access-control rules, are available to read and analyze. 

%Because of the cited advantages of \ac{pbac} and its generality and wide spread use, \ac{pbac} is the model \ac{ACCPL} implements.
Because of the cited advantages, along with its generality and
widespread use, \ac{pbac} is the model \ac{ACCPL} implements.

\subsection{A Core Policy Language for PBAC Systems} 

Currently, the most popular \ac{rel}s include the
\ac{xrml}~\cite{Wang}, and \ac{odrl}~\cite{odrloneone}. Both of these
languages are XML based and are considered declarative
languages. 
%\ac{rel}s, or more precisely \ac{drel}s when dealing with digital
%assets deal with the ``rights definition'' aspect of the \ac{drm}
%ecosystem.
\ac{rel}s, or more precisely \ac{drel}s deal with the ``rights
definition'' aspect of the \ac{drm} ecosystem of digital assets. 
A \ac{drel}, allows the expression and definition
of digital asset usage rights so that other areas of the \ac{drm}
ecosystem, namely the enforcement mechanism and the usage tracking
components can function correctly.

\ac{drm} refers to the digital management of rights associated with
the access or usage of digital assets. There are various aspects of
rights management however.
%According to the authors of the white paper ``A digital rights
%management ecosystem model for the education
%community''~\cite{collier}
According to Collier et.\ al.\ in their white paper~\cite{collier},
%
digital rights management systems comprise these categories: defining
rights, distributing/acquiring rights, enforcing rights and finally
tracking usage.

%\ac{xacml} is a high-level and platform independent access control
%system that is also XML based. No formal semantics is provided for
%\ac{xacml} similar to both \ac{xrml} and \ac{odrl}. The \ac{xacml}
%standard is written in prose and contains quite a number of loose
%points that may give rise to different interpretations and lead to
%different implementation choices~\cite{DBLP:conf/essos/MasiPT12}.

The \ac{xacml}~\cite{xacml3} is another access control policy
specification language that is general, high-level, and allows
policies to be defined in a wide variety of domains.  It is an OASIS
standard that is becoming more widely used.  Like \ac{odrl} and
\ac{xrml}, it is based on XML and the \ac{pbac} model.  \ac{odrl} and
\ac{xrml} differ from \ac{xacml} by their focus on digital assets
protection and in general \ac{drm}, hence the term \ac{drel}.  Despite
this difference, \ac{drel}s and specifically \ac{odrl} are used to
arbitrate access to assets under conditions which is very similar to
how access control conditions are expressed in access control policy
languages such as \ac{xacml} and even \ac{selinux}~\cite{selinux}. In
fact several authors have worked on interoperability between \ac{rel}s
and access control policy languages, specifically between \ac{odrl}
and
\ac{xacml}~\cite{prados2005interoperability,maronas2009architecture}.

%\ac{xacml}, \ac{odrl} and \ac{xrml} are all \ac{pbac} based languages
%where \ac{odrl} and \ac{xrml} differ from \ac{xacml} by their focus on
%digital assets protection and in general \ac{drm}, hence the term
%\ac{rel}. All three are full-blown and custom languages that have one
%thing in common; they suffer from a lack of formal
%semantics. Additionally all of these languages cover much more than
%policy expressions leading to access decisions; they also address
%enforcement of policies (\ac{odrl} and \ac{xrml} specifically and
%\ac{drm} in general distinguish themselves from general access-control
%languages by additionally addressing enforcement of policies beyond
%where the policies were generated). A third reason that made these
%custom languages unsuitable as a core policy language was the fact
%that they are limited in terms of what can be built on top of them;
%for example expressing hierarchical role-based access-control  in
%\ac{xacml} requires a fairly complex encoding~\cite{Tschantz}.

For a variety of reasons, we found \ac{xacml}, \ac{odrl} and \ac{xrml}
all to be ill-suited as the basis for a core policy language.  First,
they are all large languages that provide numerous features but suffer
from a lack of formal semantics. For example, the \ac{xacml} standard
is written in prose and contains quite a number of loose points that
may give rise to different interpretations and lead to different
implementation choices~\cite{DBLP:conf/essos/MasiPT12}.  Second, all
of these languages cover much more than policy expressions leading to
access decisions; they also address enforcement of policies (\ac{odrl}
and \ac{xrml} specifically and \ac{drm} in general distinguish
themselves from general access-control languages by additionally
addressing enforcement of policies beyond where the policies were
generated). Third, they are limited in terms of what can be built on
top of them; for example expressing hierarchical role-based
access-control in \ac{xacml} requires a fairly complex
encoding~\cite{Tschantz}.

%Rights expressions in \ac{drel}s and specifically \ac{odrl} are used
%to arbitrate access to assets under conditions which is very similar
%to how access control conditions are expressed in access control
%policy languages such as \ac{xacml} and
%\ac{selinux}~\cite{selinux}. In fact several authors have worked on
%interoperability between \ac{rel}s and access control policy
%languages, specifically between \ac{odrl} and
%\ac{xacml}~\cite{prados2005interoperability,maronas2009architecture}.

A policy language based on logic and formal semantics but one that was small and extendible was needed. We use Pucella and Weissman's subset of \ac{odrl}~\cite{pucella2006} as the starting point for \ac{ACCPL} and in doing so treat digital rights as our main access-control application without loss of generality with respect to other applications, with the final goal of performing formal verification on policies written in \ac{ACCPL}.



%----------------------------------------------------------------------
\subsection{Formal Semantics for PBAC Languages}
%----------------------------------------------------------------------


Formal methods help ensure that a system behaves correctly with respect to a specification of its desired behaviour~\cite{TAPL}. This specification of the desired behaviour is what's referred to as \emph{semantics} of the system. Using formal methods requires defining precise and formal semantics, without which analysis and reasoning about properties of the system in question would become impossible. To formalize the semantics of \ac{pbac} languages several approaches have been attempted by various authors. Most are logic based~\cite{Halpern2008,pucella2006} while others are based on finite-automata~\cite{Holzer}, operational semantics based interpreters~\cite{Safavi-naini} and web ontology (from the Knowledge Representation Field)~\cite{Kasten2010MTS}. 


%\subsection{Logic Based Semantics}
%
%
%Formal logic can represent the statements and facts we express in a natural language like English. Propositional logic is expressive enough to express simple facts as propositions and uses connectives to allow for the negation, conjunction and disjunction of the facts. In addition simple facts can be expressed conditionally using the implication connective. Propositional logic however is not expressive enough to express policies of the kind used in languages like \ac{odrl} and \ac{xrml}. For example, a simple policy expressed in English like ``All who pay 5 dollars can watch the movie Toy Story'' cannot be expressed in propositional logic because the concept of quantifiers doesn't exist in propositional logic. 
%
%A richer logic such as ``First Order Logic'' (\emph{FOL}), is more suitable and has the expressive power to represent policies written in English. Moreover, FOL can be used to capture the meaning of policies in an unambiguous way.
%
%Halpern and Weissman~\cite{Halpern2008} propose a fragment of FOL to represent and reason about policies. The fragment of FOL they arrive at is called \emph{Lithium} which is decidable and allows for efficiently answering interesting queries. Lithium restricts policies to be written, in part based on the concept of ``bipolarity'' which disallows by construction policies that both permit and deny an action on an object. Pucella and Weissman~\cite{pucella2006} specify a predicate logic based language that represents a subset of ODRL.


\subsection{Specific Problem}

Policy languages and the policies, sometimes called \emph{agreements}, written in those languages are meant to implement specific goals such as limiting access to specific assets. The tension in designing a policy language is usually between how to make the language expressive enough, such that the design goals for the policy language may be expressed, and how to make the policies verifiable with respect to the stated goals.

As stated earlier, an important part of fulfilling the verifiability goal is to have formal semantics defined for policy languages. For \ac{odrl}, authors of~\cite{pucella2006} define a formal semantics based on which they declare and prove a number of important theorems (their main focus is on stating and proving algorithm complexity results). However as with many paper-proofs, the language used to do the proofs while mathematical in nature, uses many intuitive justifications. As such these proofs are difficult to verify or to ``derive.'' Furthermore the proofs can not be used directly to render a decision on a sample policy (e.g. whether to allow or deny access to an asset). Of course one may (carefully) construct a program based on these proofs for practical purposes but certifying such programs correct presents additional verification challenges, even assuming the original proofs were in fact correct.

\subsection{Contributions}\label{sec:contribs}

We have designed a policy based access-control language called \ac{ACCPL} based on \ac{odrl} and starting with definitions in~\cite{pucella2006}. The \ac{ACCPL} framework has been encoded in \emph{Coq}~\cite{BC04} which is both a programming language and a proof-assistant. We have specified and proved \ac{ACCPL} correct with respect to properties of interest in Coq which will allow us to extract programs from the proofs; the executable programs can be used on specific policies and a query, to render a specific decision such as ``a permission has been granted.'' 

We originally started with a specific subset of~\cite{pucella2006} so that we could concentrate on what we believed to be the essence or core of the language. Initially we intended to maintain the central semantic definitions including ``Closed World Assumptions''~\cite{pucella2006} where the semantics only specify explicitly Permitted and NotPermitted answers; we discovered, however, that the semantics as stated by Pucella and Weissman~\cite{pucella2006} are not explicit and therefore the decision question that asks whether a request to access a resource may be granted or denied, may not be answered in all cases. We have therefore made major modifications to the semantics of Pucella and Weissman's language such that an answer to a request for access to a resource may be determined unambiguously and for all cases. 
%
Specifically, to consider all cases, our program evaluates a request
against each subpolicy of an agreement and returns one result for
each.  The overall result is a list of decisions.  We define what it
means to extract a single decision from a list of decisions and show
that it is always possible to extract a \emph{coherent} decision.  The
definitions and theorems required to express this notion of
correctness are detailed in Section~\ref{sec:maintheorems}.

% Moved this to the conclusion and integrated it there.    
%Our results subsume an important sub-category, namely inconsistency or conflict-detection in policy expressions or rules. St-Martin and Felty~\cite{felty16} describe and implement in Coq a conflict detection algorithm for detecting conflicts in \ac{xacml} access control rules. \ac{xacml} is an expressive and at the same time complex policy language which makes conflict detection a difficult task. The authors of~\cite{felty16} then prove the conflict detection algorithm correct (or certified) by developing a formal proof in Coq. The proof is rather complex and involves a large number of cases, including many corner cases that were difficult to get right~\cite{felty16}. For \ac{ACCPL} we have formally proven that conflicts are not possible.

Given that \ac{ACCPL} is a core policy language with semantics that have been certified correct, we could use \ac{ACCPL} to implement various (more expressive) policy languages. In addition \ac{ACCPL} could be used as an intermediate language to reason about interoperability between those policy languages~\cite{prados2005interoperability,maronas2009architecture}. In this manner our language \ac{ACCPL} can be viewed as an extendable language, complete with defined and verified semantics, that can be used as the basis for implementing various policy languages with more expressive power (e.g. W3C's \ac{odrl} and \ac{selinux}). 

For access to the Coq source code for \ac{ACCPL}, please refer to \url{http://www.site.uottawa.ca/~afelty/accpl/}.

\section{ACCPL Syntax}
%% Coq Syntax chapter

We follow the style of~\cite{pucella2006} by using abstract syntax to express policy statements in \ac{ACCPL}. 

\subsection{Environmental Facts}\label{sec:odrl0}
%To determine the outcome of policies, specified conditions in those policies are evaluated but to do so environmental facts are often needed. In the \ac{drm} realm with its focus on usage control, certain facts are typically tracked in the environment. The count of how many times an asset has been accessed, the amount a user has paid to access an asset and finally whether a user has made an attribution (e.g. mentioning the content owner by name) are examples of the kind of facts environments hold. In \ac{ACCPL}, agreements and facts (i.e. environments) will refer to a count of how many times each policy should be used and has been used respectively, to justify an action. 
To determine the outcome of requests evaluated against policies,
specified conditions in those policies must be evaluated with respect
to environmental facts. In the \ac{drm} realm with its focus on usage
control, the kinds of facts that are typically tracked in the
environment include a count of how many times an asset has been
accessed, the amount a user has paid to access an asset, and whether a
user has made an attribution (e.g. mentioning the content owner by
name). In \ac{ACCPL}, agreements and facts (i.e. environments) will
refer to a count of how many times each policy should be used and has
been used respectively, to justify an action.
Although our core language includes only one kind of fact, extending
it to other kinds is straightforward.

\subsection{Abstract Syntax for ACCPL} \label{sec:productionast}

The abstract syntax for \ac{ACCPL} is given in Listing~\ref{lst:agreementast}. 
\newcommand*{\Comment}[1]{\hfill\makebox[5.0cm][l]{#1}}%
\newcommand*{\CommentPP}[1]{\hfill\makebox[3.0cm][l]{#1}}%
% agreement
\lstset{mathescape, language=AST, escapechar=\&} 
%\begin{minipage}[c]{0.95\textwidth}
% order of elements changed so that every construct appears after it
% is mentioned in a previous construct
\begin{lstlisting}[frame=single, caption={Abstract Syntax for ACCPL},label={lst:agreementast}]
<agreement> ::= 
  'agreement' 'for' <prin> 'about' <asset> 'with'
  <policySet> 
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
<asset> ::= TheReport | ebook | latestJingle | ...
<subject> ::= Alice | Bob | ...
<act> ::= Play | Print | Display | ...
<policySet> ::=  
  <primPolicySet> &\Comment{; primitive policy set}&
<primPolicySet> ::=  
  <primInclusivePolicySet> &\Comment{; primitive inclusive policy set}&
| <primExclusivePolicySet> &\Comment{; primitive exclusive policy set}&
<primInclusivePolicySet> ::=  
  <prerequisite> $\rightarrow$ <policy> &\Comment{; primitive inclusive policy set}&
<primExclusivePolicySet> ::=  
  <prerequisite> $\mapsto$ <policy> &\Comment{; primitive exclusive policy set}&
<policy> ::=  
  'and'[ <primPolicy$_{1}$>, ..., 
         <primPolicy$_{m}$> ] &\CommentPP{; conjunction}&
<primPolicy> ::=  
  <prerequisite> $\Rightarrow_{<policyId>}$ <act> &\CommentPP{; primitive policy}&
<policyId> ::= N 
<prerequisite> ::=    
  'and'[ <primPrerequisite$_{1}$>, ..., 
         <primPrerequisite$_{m}$> ] &\Comment{; conjunction }&
<primPrerequisite> ::=  
  'True' &\Comment{; always true}&
|  <constraint>	 &\Comment{; constraint}&
|  'not' [ <constraint> ] &\Comment{; suspending constraint}&    
<constraint> ::=  
  <prin> &\Comment{; principal}&
|  'Count' [N] &\Comment{; number of executions}&
|  <prin> ('Count' [N]) &\Comment{; number of executions by prin}&     
\end{lstlisting}
%\end{minipage} 
The top level production is the \syn{<agreement>}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects called a principal or \syn{<prin>}, an \syn{<asset>} and a \syn{<policySet>}. Principals (\syn{<prin>}) are composed of subjects (\syn{<subject>}) which are specified based on the application e.g. \syn{Alice}, \syn{Bob}, etc. Assets and actions are also application specific such as \syn{TheReport} and \syn{ebook} for assets and \syn{Display} and \syn{Print} for actions. 

%A policy set is a primitive policy set implying non-nested policy sets. Each primitive policy set specifies a \syn{<prerequisite>} and a \syn{<policy>}. Intuitively if the prerequisite ``holds'' the policy is taken into consideration. Otherwise the policy will not be looked at. Some primitive policy sets are specified as inclusive as opposed to others that are explicitly specified as exclusive. Primitive exclusive policy sets are exclusive to an agreement's users in that only those users may perform the actions specified in the policy set. The implication is that all other users who are not specified in the agreement's principal are forbidden from performing the specified actions, no matter whether the prerequisite holds or not. Not surprisingly we also define primitive inclusive policy sets that don't enforce any exclusivity to the agreement's users.
A policy set (\syn{<policySet>}) is a primitive policy set
(\syn{<primPolicySet>}), where the name is meant to signify that there
is no hierarchical nesting of policy sets. Each primitive policy set
specifies a \syn{<prerequisite>} and a \syn{<policy>}. Intuitively if
the prerequisite ``holds'' the policy is taken into
consideration. Otherwise the policy will not be looked at. Some
primitive policy sets are specified as inclusive as opposed to others
that are explicitly specified as exclusive. Primitive exclusive policy
sets are exclusive to an agreement's users in that only those users
may perform the actions specified in the policy set. The implication
is that all other users who are not specified in the agreement's
principal are forbidden from performing the specified actions, no
matter whether the prerequisite holds or not. Not surprisingly, we also
define primitive inclusive policy sets that don't enforce any
exclusivity to the agreement's users.

%A primitive policy specifies an action to be performed on an asset, depending on whether the policy's prerequisite holds or not. If the prerequisite holds the agreement's user is permitted to perform the action on the agreement's asset; otherwise permission is denied. A unique identifier for each policy to help the translation (from agreements to formulas), called the policy identifier (\syn{<policyId>}) is included in our definition of the policy construct, however, as far as the proofs are concerned the policy identifier could be removed without a loss to the obtained results. A policy is made up of primitive policies. Primitive policies are grouped together using the conjunction combining operator.
A policy is made up of primitive policies. Primitive policies are
grouped together using the conjunction combining operator, specified
by the keyword \syn{and} in front of the list of the primitive
policies, which are separated by commas.  A primitive policy specifies
an action to be performed on an asset, depending on whether the
policy's prerequisite holds or not. If the prerequisite holds the
agreement's user is permitted to perform the action on the agreement's
asset; otherwise permission is denied. A unique identifier for each
policy, called the policy identifier (\syn{<policyId>}), is included
in our definition of the policy construct in order to to help the
translation (from agreements to formulas).  As far as the proofs are
concerned, however, the policy identifier could be removed without a
loss to the obtained results.

%In \ac{ACCPL}, a \syn{<primPrerequisite>} is either \syn{True} or it is a \syn{<constraint>}. The \syn{True} prerequisite always holds. A constraint is an intrinsic part of a policy and cannot be influenced by an agreement's users. A constraint can also be negative, specified by the keyword \syn{not} in front of \syn{<constraint>}. A \syn{<prerequisite>} is a set of primitive prerequisites which are closed under conjunction operator specified by the keyword `and' in front of the list of the primitive prerequisites separated by commas.
A \syn{<prerequisite>} is a set of primitive prerequisites which is
closed under the conjunction operator.  In \ac{ACCPL}, a
\syn{<primPrerequisite>} is either \syn{True} or it is a
\syn{<constraint>}. The \syn{True} prerequisite always holds. A
constraint is an intrinsic part of a policy and cannot be influenced
by an agreement's users. A constraint can also be negative, specified
by the keyword \syn{not} in front of \syn{<constraint>}.

%Constraints are either of the principal kind, the count kind, or the count by principle kind. Principal constraints require matching to the users listed following the keyword \syn{<prin>}. For example, the constraint of ``the user being Alice'' is a constraint of type principal. A count constraint refers to the number of times the user of an agreement has invoked policies to justify her actions. If the count constraint is part of a policy then the count refers to that single policy. In the case that the count constraint is part of a policy set or if the policy is a conjunction, then the count refers to the set of policies specified in the policy set or in the policy conjunction as the case may be.
Constraints are either of the principal kind, the count kind, or the
count by principle kind. Principal constraints require matching to the users listed following the keyword \syn{<prin>}. For example, the
constraint of ``the user being Alice'' is a constraint of the
principal kind. A count constraint refers to the number of times the
user of an agreement has invoked policies to justify her actions whereas a count by principal constraint is concerned with how many times a principal (not the user) has invoked the policies. 
If the count constraint is part of a policy then the count refers to that
single policy. In the case that the count constraint is part of a
policy set or if the policy is a conjunction, then the count refers to
the set of policies specified in the policy set or in the policy
conjunction as the case may be.

\subsection{ACCPL Syntax in Coq}\label{sec:agreementConstructor}

%\ac{ACCPL} productions were presented as high level abstract syntax in Section~\ref{sec:productionast}. We present the corresponding encodings in Coq in Listing~\ref{lst:agreementcoq}. Note that the data type \syn{nonemptylist} represents a list data structure that has at least one element and data types \syn{asset}, \syn{subject}, \syn{act} and \syn{policyId} are simply defined as Coq's \syn{nat}.
\ac{ACCPL} productions were presented as high level abstract syntax in
Section~\ref{sec:productionast}. We present the corresponding
encodings in Coq in Listing~\ref{lst:agreementcoq}. Note that most of
the policy constructs are defined as inductive types using Coq's
\syn{Inductive} keyword. Also, note that the data type
\syn{nonemptylist} represents a list data structure that has at least
one element.  Finally, the data types \syn{asset}, \syn{subject},
\syn{act} and \syn{policyId} are simply defined as Coq's built-in type
\syn{nat}, meaning that their elements are coded as numbers. (Their
definitions are omitted from the listing.)

\lstset{language=Coq}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={ACCPL: Coq Version of Agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
 | Agreement : prin -> asset -> policySet -> agreement.
Definition prin := nonemptylist subject.
Inductive policySet : Set :=
 | PPS : primPolicySet -> policySet.
Inductive primPolicySet : Set :=
 | PIPS : primInclusivePolicySet -> primPolicySet
 | PEPS : primExclusivePolicySet -> primPolicySet.
Inductive primInclusivePolicySet : Set :=
 | PrimitiveInclusivePolicySet : preRequisite -> policy -> primInclusivePolicySet.
Inductive primExclusivePolicySet : Set :=
 | PrimitiveExclusivePolicySet : preRequisite -> policy  -> primExclusivePolicySet.
Inductive policy : Set :=
 | Policy : nonemptylist primPolicy -> policy.
Inductive primPolicy : Set :=
 | PrimitivePolicy : preRequisite -> policyId -> act -> primPolicy.  
Inductive preRequisite : Set :=
 | PreRequisite : nonemptylist primPreRequisite -> preRequisite.
Inductive primPreRequisite : Set :=
 | TruePrq : primPreRequisite
 | Constraint : constraint -> primPreRequisite
 | NotCons : constraint -> primPreRequisite.
Inductive constraint : Set :=
 | Principal : prin  -> constraint 
 | Count : nat -> constraint 
 | CountByPrin : prin -> nat -> constraint.  
\end{lstlisting}
%\end{minipage}

%We now show the statement expressing ``the asset TheReport may be printed a total of 2 times by Alice only'' in the abstract syntax notation in~\ref{lst:agreementinAST}, as encodings of \ac{ACCPL} constructs in Coq in~\ref{lst:agreementincoq} and finally as an \ac{ACCPL} construct in~\ref{lst:agreementincoq2}.
To illustrate, Listing~\ref{lst:agreementinAST} contains an example
agreement in ACCPL expressing ``the asset TheReport may be printed a
total of 2 times by Alice only,'' followed by
Listings~\ref{lst:agreementincoq} and~\ref{lst:agreementincoq2}
showing its encoding in Coq.

\lstset{language=Pucella2006}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Example Agreement for Alice and Bob}, label={lst:agreementinAST}, mathescape]
agreement
 for Alice and Bob
 about The Report
 with True -> and[Alice, count[2]] =>$_{id1}$ print.
\end{lstlisting}
%\end{minipage}

\lstset{language=Coq, frame=single, caption={Coq Definitions for Example Agreement}, label={lst:agreementincoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition ps_xml_p1prq1:primPreRequisite := 
  (Constraint (Principal (Single Alice))).
Definition ps_xml_p1prq2:primPreRequisite := 
  (Constraint (Count 2)).
Definition ps_xml_prq:preRequisite := 
  (PreRequisite (NewList ps_xml_p1prq1 (Single ps_xml_p1prq2))).
Definition ps_xml_p1:primPolicy := 
  (PrimitivePolicy ps_xml_prq id1 Print).
Definition ps_xml_p:policy := 
  (Policy (Single ps_xml_p1)).
Definition ps_xml:primPolicySet :=
  PIPS (PrimitiveInclusivePolicySet
    (makePreRequisite TruePrq) ps_xml_p).
Definition Axml := Agreement (NewList Alice (Single Bob)) TheReport (PPS ps_xml).
\end{lstlisting}
%\end{minipage} 

\lstset{language=Coq, frame=single, caption={Fully Built Example
    Agreement in Coq}, label={lst:agreementincoq2}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Agreement (Alice, [Bob]) TheReport
         (PPS
            (PIPS
               (PrimitiveInclusivePolicySet (PreRequisite [TruePrq])
                  (Policy
                     [PrimitivePolicy
                        (PreRequisite
                           (Constraint (Principal [Alice]),
                            [Constraint (Count 2)])) id1 Print]))))

\end{lstlisting}
%\end{minipage} 

%%%% 125-semantics of ACCPL
\section{ACCPL Semantics}
%We specify the semantics of \ac{ACCPL} as a translation function from an agreement together with an access request and an environment containing all relevant facts, to decisions. This is done based on whether there are proof terms for certain conditions and/or proof terms for the negation of those conditions. The translation functions plus the auxiliary types and infrastructure which implement the semantics for \ac{ACCPL} have been encoded in Coq.
We specify the semantics of \ac{ACCPL} as a translation function (the top level \syn{trans_agreement} function) from
an agreement together with an access request and an environment
containing all relevant facts, to decisions.  In this section, we
present the algorithms as high-level pseudocode.  The reader is
referred to the Coq code for their implementation, along with all the
auxiliary types and infrastructure which implement the semantics for
\ac{ACCPL}.

%Whether an agreement and the accompanying access request or query is translated into a decision indicating a permission is granted or denied depends on the agreement in question and the specifics of the request, but also on the number of times a policy has been used to justify an action. We encode this information in Coq as an inductive type representing the environment. An \syn{environment} is a conjunction of equalities of the form \syn{count(subject, policyId) = n} which are called ``count equalities''.

%The \syn{sumbool} type is a boolean type defined in the Coq standard library; it captures the idea of program values that indicate which of two propositions is true~\cite{chlipalacpdt2011}. The \syn{sumbool} type is equipped with the justification of their value~\cite{Coq:manual} which help with proofs. We have used the \syn{sumbool} type to declare and prove decision procedures that we have subsequently used in the translation functions implementing the semantics and also in the proofs.

\subsection{Types of Decisions and their Implementation in Coq}\label{sec:answerandresulttypes}

%Policy based access-control languages typically use a two-valued decision set to indicate whether an access request is granted or denied. When a decision for a query is not granted, one design choice for a language is to return an explicit deny decision. However in this case deny stands for ``not permitted''. It is possible to have cases when the policy truly doesn't specify either a permit or a deny decision. In such cases arbitrarily returning the decision of deny makes it difficult to compose policies and in fact, an explicit decision of ``non applicable'' is warranted in such cases. Some languages may decide to only support permit decisions. In such languages lack of a permit decision for a query signifies a deny decision so deny decisions are not explicit. Although the policies of these languages may be more readable than those with more explicit decisions, they result in ambiguity on whether a deny decision was really intended or not. Finally some languages define an explicit decision of ``error'' for cases such as when both permit and deny decisions are reached for the same query. An explicit error decision is preferable to undefined behaviour because it can lead to improvements to policies and/or how the queries are built~\cite{Tschantz}. In \ac{ACCPL} we use a three-valued decision set: \syn{Permitted}, \syn{NotPermitted} and \syn{Unregulated} (used as synonymous with ``non-applicable''). 
As mentioned, in ACCPL, evaluating a request against a policy renders
a decision of ``granted'' (also called ``permitted''), ``denied'' or
``non-applicable.''  Including the ``non-applicable'' decision was
important for generality and for defining the semantics correctly.
Some policy based access-control languages use a two-valued decision,
indicating whether an access request is ``granted'' or ``denied.''  In
such languages, when a decision for a query does not evaluate to
``permit,'' the design choice taken is to return an explicit ``deny''
decision. However in this case ``deny'' stands for ``not permitted.''
It is desirable to handle the case when the policy truly doesn't
specify either a ``permit'' or a ``deny'' decision. In such cases
arbitrarily returning the decision ``deny'' makes it difficult to
compose policies.  To handle such cases, an explicit decision of ``non
applicable'' is desirable.  Alternatively, some languages may decide
to only support ``permit'' decisions. In such languages, the lack of a
``permit'' decision for a query signifies a default ``deny'' decision,
and thus ``deny'' decisions are not explicit. Although the policies of
these languages may be more readable than those with more explicit
decisions, they result in ambiguity on whether a ``deny'' decision was
really intended or not. Finally, some languages define an explicit
decision of ``error'' for cases such as when both ``permit'' and
``deny'' decisions are reached for the same query. An explicit
``error'' decision is preferable to undefined behaviour because it can
lead to improvements to policies and/or how the queries are
built~\cite{Tschantz}. The Coq encoding of our three-valued decision
set in \ac{ACCPL} is composed of the constants \syn{Permitted},
\syn{NotPermitted} and \syn{Unregulated} (used here to denote
``non-applicable'').

\subsection{Translations}\label{sec:translationfuncs}

Intuitively a query or request asks the following question given an agreement: ``May subject \syn{s} perform an action \syn{ac} to asset \syn{a}?'' We represent a query by its components, namely the subject, action and asset that form the query question: \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query} in Coq. 

%In the following we present the high-level description of how the main algorithm (encoded in the translation functions) works in two separate listings based on whether the policy set in question is inclusive or exclusive. 
Below, we present the high-level pseudocode of the main translation algorithm (implemented in the translation functions starting with \syn{trans_agreement}).
%
Listing~\ref{inclusivePS} for inclusive policy sets shows how a positive answer to a query in the form of a \syn{Permitted} decision is reached. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown. Listing~\ref{exclusivePS} for exclusive policy sets shows how a negative answer to a query in the form of a \syn{NotPermitted} decision is reached. This listing also shows that a positive decision of \syn{Permitted} is reached in exactly the same way as the case for inclusive policy sets. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown.

\lstset{language=pseudo, frame=single, caption={Access Decision Pseudocode: Inclusive Policy Sets}, label={inclusivePS}}
\begin{lstlisting}
    IF ($asset\_from\_query = asset\_from\_agreement$)
      IF ($subject\_from\_query$ is IN $prin\_u$)
        IF (The $preRequisite$ from the policy set HOLDS)
          IF (The $preRequisite$ from the policy HOLDS)
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is Permitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF            
          ELSE
             $result$ = Unregulated
          END_IF
        ELSE
          $result$ = Unregulated
        END_IF
      ELSE
           $result$ = Unregulated
      END_IF
    ELSE
      $result$ = Unregulated
    END_IF
\end{lstlisting}

\lstset{language=pseudo, frame=single, caption={Access Decision Pseudocode: Exclusive Policy Sets}, label={exclusivePS}}
\begin{lstlisting}
    IF ($asset\_from\_query = asset\_from\_agreement$)
      IF ($subject\_from\_query$ is IN $prin\_u$)
        IF (The $preRequisite$ from the policy set HOLDS)
          IF (The $preRequisite$ from the policy HOLDS)
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is Permitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF            
          ELSE
             $result$ = Unregulated
          END_IF
        ELSE
          $result$ = Unregulated
        END_IF
      ELSE
            IF ($action\_from\_query = action\_from\_agreement$)
              $result$ = $subject\_from\_query$ is NotPermitted to perform $action\_from\_query$ on $asset\_from\_query$
            ELSE
              $result$ = Unregulated
            END_IF
      END_IF
    ELSE
      $result$ = Unregulated
    END_IF
\end{lstlisting}

%%%%% 132-results chapter

\section{Correctness of ACCPL}\label{sec:maintheorems}

In this section, we present the theorems expressing the most important
properties we have proved about ACCPL.  For all supporting lemmas and
for all proofs, the reader is referred to the accompanying Coq code.

\subsection{Correctness of Translation}\label{sec:correct}

The theorem in Listing~\ref{lst:agreementdecidablecoq} is the declaration of the main correctness result for \ac{ACCPL}. Together with proofs for other theorems and lemmas, we have ``certified'' \ac{ACCPL} correct by proving this theorem.

\lstset{language=Coq, frame=single, caption={Agreement Translation's Correctness Property},label={lst:agreementdecidablecoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_dec2:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),
   
 (isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
\/
 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))
\/
 (~(isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\
  ~(isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))).
\end{lstlisting}
%\end{minipage}

The nonempty list that the agreement translation function \syn{trans_agreement} returns will contain results one per each primitive policy (\syn{primPolicy}) found in the agreement. Specifically the predicate \syn{isResultInQueryResult} takes a \syn{result} and a nonempty list of \syn{result}'s which \syn{trans_agreement} produces, and calls Coq's built-in \syn{In} predicate. This predicate checks for the existence of the input \syn{result} in the nonempty list of results.

Note that by mentioning the agreement translation function directly in the statement of the theorem in Listing~\ref{lst:agreementdecidablecoq}, we tie the correctness property to how the translation functions work. To prove the theorem and with each successive subgoal during the interactive proof process, the definition of the translation function in scope gets unfolded and used so the translation functions have to be defined such that each subgoal is discharged and the proof is completed. 

%As an example and also a visual aid to understanding how queries are answered, see Listing~\ref{lst:permittedcoq}. The \syn{isResultInQueryResult} predicate looks for a result with an answer of Permitted in the list that \syn{trans_agreement} has produced, for an agreement for three primitive policies (since the set contains three results). In words, we are asking whether Alice is allowed to print the asset ebook, given a policy. 

As an example and also a visual aid to understanding how queries are
answered, see Listing~\ref{lst:permittedcoq}.
%
\lstset{language=Coq, frame=single, caption={Access Request Resulting in Decision of \syn{Permitted}},label={lst:permittedcoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
isResultInQueryResult
(Result Permitted Alice Print ebook) 
[ (Result Unregulated Alice Print ebook) ; (Result Unregulated Alice Print ebook) ; (Result Permitted Alice Print ebook) ]
\end{lstlisting}
%\end{minipage}
The \syn{isResultInQueryResult} predicate looks for a result with an
answer of Permitted in the list that \syn{trans_agreement} has
produced, for an agreement for three primitive policies (since the set
contains three results). In words, we are asking whether Alice is
allowed to print the asset ebook, given a policy.
    
In the case where the whole set is not comprised of \syn{Unregulated} results, we have two mutually exclusive cases. The first case is when the set has a at least one \syn{Permitted} result; we answer the access query in this case with a result of \syn{Permitted}. (This would be the case in the Listing~\ref{lst:permittedcoq}.) The second case is when the set has at least one \syn{NotPermitted}; we answer the access query in this case with a result of \syn{NotPermitted}. 

Typically most, if not all of the results will be of type \syn{Unregulated}. In the case where all the results are \syn{Unregulated} we answer the access query with a result of \syn{Unregulated}. We show this case indirectly in the theorem in Listing~\ref{lst:agreementdecidablecoq} by stating the set does not contain a \syn{Permitted} result nor a \syn{NotPermitted} result. 

\subsection{Mutual Exclusivity of \syn{Permitted} and \syn{NotPermitted}}\label{sec:mutualexclusive}

%The proof for \syn{trans_agreement_not_Perm_and_NotPerm_at_once} establishes that both \syn{Permitted} and \syn{NotPermitted} results cannot exist in the same set returned by \syn{trans_agreement} (see listing~\ref{lst:permandnotpermmutualexclusive}). This result also establishes the fact that in \ac{ACCPL} rendering conflicting decisions is not possible given an agreement. 
The proof of the theorem in
Listing~\ref{lst:permandnotpermmutualexclusive} establishes that both
\syn{Permitted} and \syn{NotPermitted} results cannot exist in the
same set returned by \syn{trans_agreement}.  This result also
establishes the fact that in \ac{ACCPL} rendering conflicting
decisions is not possible given an agreement.

\lstset{language=Coq, frame=single, caption={\syn{Permitted} and \syn{NotPermitted}: Mutually Exclusive},label={lst:permandnotpermmutualexclusive}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_not_Perm_and_NotPerm_at_once:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),

 ~((isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
/\
 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))).
\end{lstlisting}
%\end{minipage}

%The proof for the next theorem \syn{trans_agreement_not_NotPerm_and_not_Perm \newline _implies_Unregulated_dec} shows that in the case where neither a \syn{Permitted} nor a \syn{NotPermitted} result exists in the set returned by \syn{trans_agreement}, there does exist at least one \syn{Unregulated} result (see listing~\ref{lst:notpermandnotpermimpliesunregulated}).
The proof of the theorem in
Listing~\ref{lst:notpermandnotpermimpliesunregulated} shows that in
the case where neither a \syn{Permitted} nor a \syn{NotPermitted}
result exists in the set returned by \syn{trans_agreement}, there does
exist at least one \syn{Unregulated} result.

\lstset{language=Coq, frame=single, caption={Not (\syn{Permitted} and \syn{NotPermitted}) Implies \syn{Unregulated}},label={lst:notpermandnotpermimpliesunregulated}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_not_NotPerm_and_not_Perm_implies_Unregulated_dec:
  forall
    (e:environment)(ag:agreement)(action_from_query:act)
    (subject_from_query:subject)(asset_from_query:asset),

    (~(isResultInQueryResult 
      (Result Permitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\

    ~(isResultInQueryResult 
      (Result NotPermitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query))) ->

   (isResultInQueryResult 
      (Result Unregulated subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)).
\end{lstlisting}
%\end{minipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\blindtext\todo{Refine me}


%\begin{figure}
%Simple Figure
%\caption{Simple Figure}
%\label{fig:simple}
%\end{figure}
%
%\begin{table}
%\caption{Simple Table}
%
%\label{tab:simple}
%Simple Table
%\end{table}

%cref Demonstration: Cref at beginning of sentence, cref in all other cases.
%
%\Cref{fig:simple} shows a simple fact, although \cref{fig:simple} could also show something else.
%
%\Cref{tab:simple} shows a simple fact, although \cref{tab:simple} could also show something else.
%
%\Cref{sec:intro} shows a simple fact, although \cref{sec:intro} could also show something else.
%
%Brackets work as designed:
%<test>
%
%The symbol for powerset is now correct: $\powerset$ and not a Weierstrass p ($\wp$).
%
%\begin{inparaenum}
%\item All these items...
%\item ...appear in one line
%\item This is enabled by the paralist package.
%\end{inparaenum}
%
%``something in quotes'' using plain tex or use \enquote{the enquote command}.

\section{Conclusion}
We have presented the design and implementation of \ac{ACCPL} as a small and certifiably correct policy language. \ac{ACCPL} is a \ac{pbac} system that can be used to express general access-control rules and policies. In addition we have defined formal semantics for \ac{ACCPL} where we have discovered and added all possible cases when answering a query on whether to allow or deny an action to be performed on an asset. We have subsequently used the Coq Proof Assistant to state theorems about the expected behaviour of \ac{ACCPL} when evaluating a request with respect to a given policy, to develop proofs for those theorems and to machine-check the proofs ensuring correctness guarantees are provided. We have in particular stated, developed and proved correctness results for the semantics of \ac{ACCPL}. 

Additionally, we have described why certain design choices were made and how they contributed to the ease of reasoning for \ac{ACCPL}. Admittedly some expressive power present in other access-control policy languages was omitted from \ac{ACCPL} in order to achieve the reported correctness proofs. For example, in \ac{ACCPL} we only support base policy sets (policy sets that are not composed of other policy sets) i.e., no combining of base policy sets using conjunctions or other combining operators are supported. 

\subsection{Related Work}
We review here related work and approaches
to defining semantics for \ac{pbac} based languages so that one can
determine without any ambiguity whether a permission or prohibition
follows from a set of policy statements.
 
%\subsection{Lithium}
Halpern and Weissman~\cite{Halpern2008} use \ac{fol} to represent and reason about policies; policies describe the conditions under which a request to perform an action, such as reading a file, is granted or denied. They restrict \ac{fol} to get tractability for answering the query of whether a request to access a resource may be granted or denied, given a policy, and argue that despite the tractability results their language is still expressive. The authors focus on satisfying three requirements in the design of their language Lithium: expressive enough, tractable enough and usable by non-experts.

%In contrast, our main goal was designing a core policy language with certifiably correct semantics such that it could be extended in different ways to add expressiveness as long as the semantics would remain certifiably correct with respect to established results for \ac{ACCPL}. We note that \ac{ACCPL} may not be a good candidate to satisfy Halpern and Weissman's first goal. We have not (yet) considered the other Lithium design goals for \ac{ACCPL}.
%

%\subsection{Trace-based Semantics}
%Gunter, et al~\cite{GunterWW01} propose an abstract model and a formal language to express access and usage rights for digital assets. A set of ``realities'' representing a sequence of \emph{payment} and \emph{render} (e.g. work is rendered by a device) actions make up a license. Semantics in the authors' model are expressed as a function mapping terms of the language to elements of the domain of licenses. The authors argue that their semantics is similar to those used for concurrency where language constructs are modelled as traces of allowed events.

%\subsection{Semantics Based on Linear Logic}
%
%Barth and Mitchell~\cite{BarthM06} express semantics of digital rights using propositional linear logic. Linear logic deals with dynamic properties or finite resources, while classical logic deals with stable truths, or static properties~\cite{Girard87}. Bart and Mitchell introduce the notion of monotonicity which captures the idea that acquiring extra rights by a user should not lead to the user having fewer rights and show that the algorithm the \ac{oma} uses for assigning actions to rights is non-monotonic. Barth and Mitchell consider whether a sequence of actions complies with a license and show that answering this question for the \ac{oma} language is NP-complete. They propose an algorithm based on propositional linear logic to evaluate sequences of actions that is monotonic.

%\subsection{Automata-based Semantics}
Holzer, et al~\cite{Holzer} give a semantics for \ac{odrl} that models the actions that are allowed according to a contract or an agreement. This model is presented in terms of automata. Each trace through the automaton represents a valid sequence of actions for each participant. The states of the automaton encode the state of the license at each point in time, meaning, which actions are allowed at what point considering the actions that have taken place in the past. 

%\subsection{Operational Semantics}
%Sheppard and Safavi-Naini~\cite{SheppardS09} propose an operational model for both formalizing and enforcing digital rights using a \emph{right expression compiler}. They use their model to develop operational semantics for \ac{oma}, from which an interpreter could be derived. 

%\subsection{Conflict Detection Algorithms}
Capretta, et al~\cite{CaprettaSFM07} present a conflict detection algorithm for the Cisco firewall specification~\cite{ciscofirewall} and formalize a correctness proof for it in the Coq proof assistant. The authors present their algorithm in Coq's functional programming language along with access rules and requests which are also encoded in Coq. The authors also prove in~\cite{CaprettaSFM07} that their algorithm finds all conflicts and only the correct conflicts in a set of rules. The algorithm is therefore verified formally to be both sound and complete.

Extending the above work, St-Martin and Felty~\cite{felty16} represent
policies for a fragment of \ac{xacml} 3.0 in the Coq proof assistant,
propose an algorithm for detecting all conflicts in \ac{xacml}
policies, and prove it correct. Their \ac{xacml} subset includes some
complex conditions such as time constraints. The policy language and
thus the conflict detection algorithm for XACML is much more complex
than the one for Cisco firewalls, and resulted in having to consider
many cases including many subtle corner cases.

\subsection{Future Work}

%There are a number of directions that can be taken as future work. In the following we list three distinct directions that could be combined at various stages.

Our results subsume the above results on conflict detection in the
sense that for \ac{ACCPL}, we have formally proven that conflicts are
not possible.  This is an important aspect of our small certified core
language, but as this core is extended to cover more of the expressive
power of existing policy languages, this property will likely no
longer hold.  By starting with a conflict-free core, our goal is to
keep conflict detection as simple as possible as we add more features.

Tschantz and Krishnamurthi's~\cite{Tschantz} present a set of ``reasonability properties'' to analyze the behaviour of policies in light of additional and/or explicit environmental facts and policy growth and decomposition. We conjecture that \ac{ACCPL} supports these properties: it is deterministic, total, safe, and it has independent composition property and supports a monotonic policy combinator. However, we have not yet certified (using formal proofs) that \ac{ACCPL} has these properties, as we claim. We defer proving these properties for \ac{ACCPL} as future work. 

Another direction for future work is to explore different ways \ac{ACCPL} could be made more expressive. For example, we can add various policy combinators and their semantics to \ac{ACCPL} using the translation function framework. The translation function framework we have developed for \ac{ACCPL} is meant to keep the delicate balance between addition of expressiveness while maintaining provability of established results.

Another design goal for \ac{ACCPL} was to make it a target language for deploying policies written in other languages. We could capture, implement and study the semantics of these other policy-based access-control systems using the \ac{ACCPL} translation function framework and ultimately certify the semantics of those languages with respect to their specifications the same way \ac{ACCPL} has been certified correct. For example, we can take another \ac{pbac} system such as \ac{xrml} and \ac{odrl}, implement them in Coq as additional or (modifications of) existing \ac{ACCPL} constructs, analyze and reason about them, etc. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{splncs03}
\bibliography{accpl-sbmf2016}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
